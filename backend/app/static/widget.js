/**
 * AI Chatbot Builder - Embeddable Widget
 * This script creates a floating chatbot widget that can be embedded on any website
 */

(function () {
  "use strict";

  // Configuration
  const WIDGET_VERSION = "1.0.0";
  const DEFAULT_API_URL = "http://localhost:8000";

  // Color configuration (can be overridden from backend)
  const DEFAULT_COLORS = {
    primary: "#000000",
    secondary: "#7C3AED",
    accent: "#F97316",
    success: "#10B981",
  };

  // Widget state
  let widgetConfig = null;
  let isOpen = false;
  let websocket = null;
  let isConnecting = false; // Track if WebSocket is currently connecting
  let sessionId = null;
  let messages = [];
  let reconnectAttempts = 0;
  const MAX_RECONNECT_ATTEMPTS = 5;
  let darkModeMediaQuery = null;
  let streamingAssistantMessage = null; // holds current streaming assistant message DOM + text
  let currentConversationId = null; // Track current conversation ID
  let isHistoryView = false; // Track if we're viewing history
  let conversationHistory = []; // Store conversation history in memory (cached from API)
  let conversationHistoryCache = null; // Cache timestamp to avoid frequent API calls
  const CONVERSATION_CACHE_TTL = 30000; // Cache for 30 seconds
  let processedMessageIds = new Set(); // Track processed message IDs to prevent duplicates

  // Generate unique session ID
  function generateSessionId() {
    return (
      "session_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9)
    );
  }

  // Note: Conversation IDs are generated by the backend, not the client

  // Get storage key for client UUID (per chatbot)
  function getClientUuidStorageKey() {
    if (!widgetConfig) return null;
    return `chatbot_client_uuid_${widgetConfig.uuid}`;
  }

  // Get client UUID from localStorage
  function getClientUuid() {
    const key = getClientUuidStorageKey();
    if (!key) return null;

    try {
      return localStorage.getItem(key);
    } catch (error) {
      console.error("[WIDGET] Error loading client_uuid:", error);
      return null;
    }
  }

  // Save client UUID to localStorage
  function saveClientUuid(clientUuid) {
    const key = getClientUuidStorageKey();
    if (!key || !clientUuid) return;

    try {
      localStorage.setItem(key, clientUuid);
      console.log("[WIDGET] ✅ Saved client_uuid to localStorage:", clientUuid);
    } catch (error) {
      console.error("[WIDGET] Error saving client_uuid:", error);
    }
  }

  // Fetch conversations from API and cache in memory
  async function fetchConversationsForHistory() {
    // Check cache first
    if (
      conversationHistoryCache &&
      Date.now() - conversationHistoryCache.timestamp <
        CONVERSATION_CACHE_TTL &&
      conversationHistoryCache.data.length > 0
    ) {
      console.log("[WIDGET] Using cached conversation history");
      return conversationHistoryCache.data;
    }

    // Fetch from API using client_uuid
    const clientUuid = getClientUuid();
    if (!clientUuid) {
      console.log("[WIDGET] No client_uuid available, cannot fetch history");
      return [];
    }

    if (!widgetConfig) return [];

    const apiUrl = getApiUrl();
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;

    try {
      const response = await fetch(
        `${baseUrl}/api/chat/${
          widgetConfig.uuid
        }/conversations/by-session?client_uuid=${encodeURIComponent(
          clientUuid
        )}&limit=10`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (response.ok) {
        const data = await response.json();
        // Convert backend format to widget format
        const conversations = data.conversations.map((conv) => ({
          uuid: conv.uuid,
          session_id: conv.session_id,
          title: conv.last_user_message || "New conversation",
          status: conv.status,
          created_at: conv.created_at,
          updated_at: conv.updated_at,
        }));

        // Cache in memory
        conversationHistoryCache = {
          data: conversations,
          timestamp: Date.now(),
        };

        console.log(
          "[WIDGET] ✅ Fetched and cached",
          conversations.length,
          "conversations"
        );
        return conversations;
      } else {
        console.error(
          "[WIDGET] Failed to fetch conversations:",
          response.status
        );
        return [];
      }
    } catch (error) {
      console.error("[WIDGET] Error fetching conversations:", error);
      return [];
    }
  }

  // Fetch conversations from backend by client_uuid (preferred) or session_id (fallback)
  async function fetchConversationsFromBackend(sessionIdToUse = null) {
    if (!widgetConfig) return [];

    const apiUrl = getApiUrl();
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;

    // Prefer client_uuid over session_id for fetching conversations
    const clientUuid = getClientUuid();
    let fetchUrl;

    if (clientUuid) {
      // Use client_uuid to fetch all conversations for this client
      fetchUrl = `${baseUrl}/api/chat/${
        widgetConfig.uuid
      }/conversations/by-session?client_uuid=${encodeURIComponent(
        clientUuid
      )}&limit=50`;
      console.log(
        "[WIDGET] Fetching conversations by client_uuid:",
        clientUuid
      );
    } else {
      // Fallback to session_id for backward compatibility
      const sessionIdForFetch = sessionIdToUse || sessionId;
      if (!sessionIdForFetch) return [];

      fetchUrl = `${baseUrl}/api/chat/${
        widgetConfig.uuid
      }/conversations/by-session?session_id=${encodeURIComponent(
        sessionIdForFetch
      )}&limit=50`;
      console.log(
        "[WIDGET] Fetching conversations by session_id:",
        sessionIdForFetch
      );
    }

    try {
      const response = await fetch(fetchUrl, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (response.ok) {
        const data = await response.json();
        // Convert backend format to widget format
        return data.conversations.map((conv) => ({
          uuid: conv.uuid,
          session_id: conv.session_id,
          title: conv.last_user_message || "New conversation",
          status: conv.status,
          created_at: conv.created_at,
          updated_at: conv.updated_at,
        }));
      } else {
        console.error(
          "[WIDGET] Failed to fetch conversations:",
          response.status
        );
        return [];
      }
    } catch (error) {
      console.error("[WIDGET] Error fetching conversations:", error);
      return [];
    }
  }

  // Fetch conversations for client_uuid (preferred) or all known session_ids from localStorage
  // Fetch all conversations for client_uuid (uses API and memory cache)
  async function fetchAllConversationsFromBackend() {
    // Use the same function as history - fetches from API and caches in memory
    return await fetchConversationsForHistory();
  }

  // Fetch full conversation messages from backend
  async function fetchConversationMessages(
    conversationUuid,
    sessionIdToUse = null
  ) {
    if (!widgetConfig) return null;

    // Use provided session_id or try to find it from cached conversation
    let sessionIdForFetch = sessionIdToUse || sessionId;
    if (!sessionIdForFetch) {
      // Try to find session_id from cached conversation
      const cachedConv = conversationHistory.find(
        (c) => c.uuid === conversationUuid
      );
      if (cachedConv && cachedConv.session_id) {
        sessionIdForFetch = cachedConv.session_id;
      } else {
        console.error("[WIDGET] No session_id available for conversation");
        return null;
      }
    }

    const apiUrl = getApiUrl();
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;

    try {
      const response = await fetch(
        `${baseUrl}/api/chat/conversations/${conversationUuid}/messages?session_id=${encodeURIComponent(
          sessionIdForFetch
        )}&limit=100`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (response.ok) {
        const messages = await response.json();
        return messages.map((msg) => ({
          role: msg.role,
          content: msg.content,
          messageId: msg.id,
          timestamp: msg.created_at,
        }));
      } else {
        console.error("[WIDGET] Failed to fetch messages:", response.status);
        return null;
      }
    } catch (error) {
      console.error("[WIDGET] Error fetching messages:", error);
      return null;
    }
  }

  // Update conversation metadata in cache (called after backend operations)
  function updateConversationMetadata(uuid, title, status, updatedAt) {
    // Update in-memory cache
    let conversation = conversationHistory.find((c) => c.uuid === uuid);
    const isNewConversation = !conversation;

    if (!conversation) {
      conversation = {
        uuid: uuid,
        session_id: sessionId,
        title: title,
        status: status,
        created_at: updatedAt,
        updated_at: updatedAt,
      };
      conversationHistory.unshift(conversation);
    } else {
      conversation.title = title;
      conversation.status = status;
      conversation.updated_at = updatedAt;
      // Update session_id if it changed
      if (sessionId) {
        conversation.session_id = sessionId;
      }
      // Move to front (most recent)
      const index = conversationHistory.indexOf(conversation);
      if (index > 0) {
        conversationHistory.splice(index, 1);
        conversationHistory.unshift(conversation);
      }
    }

    // Invalidate cache to force refresh on next fetch
    conversationHistoryCache = null;

    // If history view is currently open, refresh it to show the new/updated conversation
    if (isHistoryView) {
      const historyContainer = document.getElementById(
        "chatbot-history-container"
      );
      if (historyContainer && historyContainer.style.display !== "none") {
        console.log("[WIDGET] History view is open, refreshing history list");
        renderHistoryList();
      }
    }
  }

  // Get conversation title from first user message
  function getConversationTitle() {
    const firstUserMessage = messages.find((m) => m.role === "user");
    if (firstUserMessage && firstUserMessage.content) {
      const title = firstUserMessage.content.trim();
      return title.length > 50 ? title.substring(0, 50) + "..." : title;
    }
    return "New conversation";
  }

  // Load conversation from history (fetches from backend)
  async function loadConversation(conversationUuid) {
    // First, refresh history from backend to ensure we have the latest data
    conversationHistoryCache = null;
    const fetchedConversations = await fetchConversationsForHistory();
    conversationHistory = fetchedConversations;

    const conversation = conversationHistory.find(
      (c) => c.uuid === conversationUuid
    );
    if (!conversation) {
      console.error("[WIDGET] Conversation not found in cache");
      return false;
    }

    // Allow loading closed conversations (for viewing), but don't allow sending messages
    const isClosed = conversation.status === "closed";

    currentConversationId = conversationUuid;

    // Restore the conversation's session_id to allow continuing old conversations
    // This enables users to continue messaging in old conversations even after page refresh
    const conversationSessionId = conversation.session_id;
    if (conversationSessionId) {
      sessionId = conversationSessionId;
      console.log(
        "[WIDGET] ✅ Loaded conversation:",
        conversationUuid,
        "with session_id:",
        conversationSessionId
      );
    } else {
      console.error("[WIDGET] ❌ Conversation has no session_id");
      return false;
    }

    // Show loading state
    const messagesContainer = document.getElementById("chatbot-messages");
    if (messagesContainer) {
      messagesContainer.innerHTML =
        '<div style="padding: 20px; text-align: center; color: #6b7280;">Loading conversation...</div>';
    }

    // Fetch messages from backend using the conversation's session_id
    const fetchedMessages = await fetchConversationMessages(
      conversationUuid,
      conversationSessionId
    );
    if (!fetchedMessages) {
      console.error("[WIDGET] Failed to load conversation messages");
      if (messagesContainer) {
        messagesContainer.innerHTML =
          '<div style="padding: 20px; text-align: center; color: #ef4444;">Failed to load conversation</div>';
      }
      return false;
    }

    // currentConversationId is already set above
    messages = fetchedMessages;

    // Clear streaming state and processed message IDs
    streamingAssistantMessage = null;
    processedMessageIds.clear();

    // Add all message IDs to processed set to prevent duplicates
    fetchedMessages.forEach((msg) => {
      if (msg.messageId) {
        processedMessageIds.add(msg.messageId);
      }
    });

    // Clear and render messages
    if (messagesContainer) {
      messagesContainer.innerHTML = "";

      // Render all messages
      messages.forEach((msg) => {
        addMessageToDOM(
          msg.role,
          msg.content,
          msg.agentName,
          msg.messageId,
          msg.timestamp
        );
      });

      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Hide typing indicator if visible
    const typingIndicator = getTypingIndicator();
    if (typingIndicator) {
      typingIndicator.style.display = "none";
    }

    // Reconnect WebSocket with the session ID (only if conversation is not closed)
    if (!isClosed) {
      // Close existing connection properly
      if (websocket) {
        websocket.onclose = null; // Prevent reconnection attempt
        if (
          websocket.readyState === WebSocket.OPEN ||
          websocket.readyState === WebSocket.CONNECTING
        ) {
          websocket.close();
        }
        websocket = null;
      }
      isConnecting = false;
      // Clear processed message IDs for new conversation context
      processedMessageIds.clear();
      connectWebSocket();
    }

    // Switch back to messages view and update header
    showMessagesView(conversation.status);

    return true;
  }

  // Start new conversation - maintains consistent design
  function startNewConversation() {
    console.log("[WIDGET] startNewConversation called");

    currentConversationId = null; // Will be set by backend when first message is sent
    messages = [];
    processedMessageIds.clear(); // Clear processed message IDs
    streamingAssistantMessage = null; // Clear streaming state

    // Generate new session ID (new conversation = new session)
    // This is CRITICAL - new session = new conversation on backend
    sessionId = generateSessionId();
    console.log(
      "[WIDGET] ✅ Generated new sessionId for NEW conversation:",
      sessionId
    );

    // Close existing WebSocket connection completely
    if (websocket) {
      websocket.onclose = null; // Prevent automatic reconnection attempt
      websocket.onmessage = null; // Clear message handler
      websocket.onerror = null; // Clear error handler
      if (
        websocket.readyState === WebSocket.OPEN ||
        websocket.readyState === WebSocket.CONNECTING
      ) {
        websocket.close();
      }
      websocket = null;
    }
    isConnecting = false;

    // CRITICAL: Reconnect WebSocket with NEW sessionId
    // This ensures the backend knows this is a new conversation
    console.log("[WIDGET] ✅ Reconnecting WebSocket with new sessionId");
    connectWebSocket();

    // Ensure we're not in history view
    isHistoryView = false;

    // Hide history container if visible
    const historyContainer = document.getElementById(
      "chatbot-history-container"
    );
    if (historyContainer) {
      historyContainer.style.display = "none";
    }

    // Clear messages container and restore initial state
    const messagesContainer = document.getElementById("chatbot-messages");
    if (messagesContainer) {
      // Clear all existing messages
      messagesContainer.innerHTML = "";

      // Always show welcome message (consistent design)
      const apiUrl = getApiUrl();
      const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
      const logoUrl = `${baseUrl}/chat-logo.png`;
      const welcomeDiv = document.createElement("div");
      welcomeDiv.className = "chatbot-welcome";
      welcomeDiv.innerHTML = `
        <div class="chatbot-welcome-header">
          <img src="${logoUrl}" alt="Bot" class="chatbot-avatar" />
          <div class="chatbot-welcome-name">${
            widgetConfig?.name || "Chatbot"
          }</div>
        </div>
        <div class="chatbot-welcome-text">${
          widgetConfig?.welcomeMessage || "Hi! What can I help you with?"
        }</div>
      `;
      messagesContainer.appendChild(welcomeDiv);

      // Apply styling to the newly created welcome message
      if (widgetConfig?.styling) {
        applyStyling(widgetConfig.styling);
      }

      // Show examples if available (consistent with initial design)
      displayExampleMessages();

      // Also show separator if examples are visible
      const examples = document.getElementById("chatbot-examples");
      const examplesSeparator = document.querySelector(
        ".chatbot-examples-separator"
      );
      if (examples && examples.style.display === "flex") {
        if (examplesSeparator) examplesSeparator.style.display = "block";
      } else {
        if (examplesSeparator) examplesSeparator.style.display = "none";
      }
    }

    // Invalidate conversation cache to force refresh on next history view
    conversationHistoryCache = null;
    console.log("[WIDGET] ✅ Invalidated conversation cache");

    // Reconnect WebSocket with new session
    // Close existing connection completely first
    if (websocket) {
      websocket.onclose = null; // Prevent automatic reconnection
      websocket.onmessage = null; // Clear handlers
      websocket.onerror = null;
      if (
        websocket.readyState === WebSocket.OPEN ||
        websocket.readyState === WebSocket.CONNECTING
      ) {
        websocket.close();
      }
      websocket = null;
    }
    isConnecting = false;

    // Now connect with the NEW sessionId (this ensures backend creates new conversation)
    console.log(
      "[WIDGET] ✅ Connecting WebSocket with NEW sessionId:",
      sessionId
    );
    connectWebSocket();

    // Switch back to messages view (ensure header is correct)
    showMessagesView();
    console.log("[WIDGET] ✅ New conversation started");
  }

  // End current conversation
  async function endCurrentConversation() {
    if (!currentConversationId) return;

    const apiUrl = getApiUrl();
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;

    try {
      // Update status on backend
      const response = await fetch(
        `${baseUrl}/api/chat/conversations/${currentConversationId}/status?status=closed`,
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (response.ok) {
        // Update local cache
        const conversation = conversationHistory.find(
          (c) => c.uuid === currentConversationId
        );
        if (conversation) {
          conversation.status = "closed";
          conversation.updated_at = new Date().toISOString();
          // Invalidate cache to force refresh
          conversationHistoryCache = null;
        }
      }
    } catch (error) {
      console.error("[WIDGET] Error closing conversation:", error);
    }

    // Start new conversation
    startNewConversation();
  }

  // Show history view
  function showHistoryView() {
    console.log("[WIDGET] showHistoryView called");
    isHistoryView = true;

    const messagesContainer = document.getElementById("chatbot-messages");
    let historyContainer = document.getElementById("chatbot-history-container");

    // Ensure history container exists - create it if it doesn't
    if (!historyContainer && messagesContainer) {
      console.log("[WIDGET] Creating history container");
      historyContainer = document.createElement("div");
      historyContainer.id = "chatbot-history-container";
      historyContainer.className = "chatbot-history-container";
      historyContainer.style.display = "none";

      const historyList = document.createElement("div");
      historyList.id = "chatbot-history-list";
      historyList.className = "chatbot-history-list";
      historyContainer.appendChild(historyList);

      messagesContainer.appendChild(historyContainer);
    }

    const typingIndicator = getTypingIndicator();
    const inputContainer = document.querySelector(".chatbot-input-container");
    const titleElement = document.querySelector(".chatbot-title");
    const logoElement = document.getElementById("chatbot-header-logo");

    // Always update header first
    if (titleElement) {
      titleElement.textContent = "Recent chats";
      console.log("[WIDGET] ✅ Changed title to 'Recent chats'");
    } else {
      console.warn("[WIDGET] ⚠️ Title element not found");
    }

    // Replace logo with back arrow icon
    if (logoElement) {
      logoElement.style.display = "none";
      let backButton = document.getElementById("chatbot-header-back");
      if (!backButton) {
        backButton = document.createElement("button");
        backButton.id = "chatbot-header-back";
        backButton.className = "chatbot-header-back";
        backButton.setAttribute("aria-label", "Back to chat");
        backButton.style.background = "none";
        backButton.style.border = "none";
        backButton.style.cursor = "pointer";
        backButton.style.padding = "0";
        backButton.style.marginRight = "10px";
        backButton.style.display = "flex";
        backButton.style.alignItems = "center";
        backButton.style.justifyContent = "center";
        backButton.style.width = "30px";
        backButton.style.height = "30px";
        backButton.style.color = "#fff";
        backButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left-icon lucide-chevron-left"><path d="m15 18-6-6 6-6"/></svg>`;
        backButton.addEventListener("click", () => {
          console.log("[WIDGET] Back button clicked");
          showMessagesView();
        });
        logoElement.parentNode.insertBefore(backButton, logoElement);
        console.log("[WIDGET] ✅ Created back button");
      }
      backButton.style.display = "flex";
    } else {
      console.warn("[WIDGET] ⚠️ Logo element not found");
    }

    // Hide messages if container exists
    if (messagesContainer) {
      const allMessages = messagesContainer.querySelectorAll(
        ".chatbot-message, .chatbot-welcome"
      );
      allMessages.forEach((msg) => (msg.style.display = "none"));
      console.log("[WIDGET] ✅ Hid", allMessages.length, "messages");
    }

    // Hide typing indicator
    if (typingIndicator) {
      typingIndicator.style.display = "none";
    }

    // Hide input container
    if (inputContainer) {
      inputContainer.style.display = "none";
      console.log("[WIDGET] ✅ Hid input container");
    }

    // Show history container
    if (historyContainer) {
      historyContainer.style.display = "flex";
      console.log("[WIDGET] ✅ Showing history container");

      // Render history list
      renderHistoryList();
    } else {
      console.error("[WIDGET] ❌ History container not found!");
    }
  }

  // Show messages view
  function showMessagesView(conversationStatus = null) {
    isHistoryView = false;
    const messagesContainer = document.getElementById("chatbot-messages");
    const historyContainer = document.getElementById(
      "chatbot-history-container"
    );
    const inputContainer = document.querySelector(".chatbot-input-container");
    const titleElement = document.querySelector(".chatbot-title");
    const logoElement = document.getElementById("chatbot-header-logo");
    const backButton = document.getElementById("chatbot-header-back");

    // Always restore header elements first, regardless of container checks
    // Restore original chatbot name in header
    if (titleElement && widgetConfig) {
      titleElement.textContent = widgetConfig.name || "Chatbot";
      console.log(
        "[WIDGET] ✅ Restored chatbot name in header:",
        widgetConfig.name
      );
    } else {
      console.warn("[WIDGET] ⚠️ Title element or widgetConfig not found");
    }

    // Restore logo and hide back button
    if (logoElement) {
      logoElement.style.display = "block";
      console.log("[WIDGET] ✅ Restored logo in header");
    } else {
      console.warn("[WIDGET] ⚠️ Logo element not found");
    }

    if (backButton) {
      backButton.style.display = "none";
      console.log("[WIDGET] ✅ Hid back button");
    }

    // Hide history container
    if (historyContainer) {
      historyContainer.style.display = "none";
    }

    // Show or hide input container based on conversation status
    // Show input if conversation is not closed, hide if closed
    if (inputContainer) {
      if (conversationStatus === "closed") {
        inputContainer.style.display = "none";
      } else {
        inputContainer.style.display = "block";
      }
    }

    // Show messages if container exists
    if (messagesContainer) {
      const allMessages = messagesContainer.querySelectorAll(
        ".chatbot-message, .chatbot-welcome"
      );
      allMessages.forEach((msg) => (msg.style.display = ""));

      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }

  // Render history list (fetches from backend API using client_uuid)
  async function renderHistoryList() {
    console.log("[WIDGET] renderHistoryList called");
    const historyList = document.getElementById("chatbot-history-list");
    if (!historyList) {
      console.error("[WIDGET] ❌ History list element not found!");
      return;
    }

    // Show loading state
    historyList.innerHTML =
      '<div class="chatbot-history-empty">Loading...</div>';

    try {
      // Always fetch from backend (invalidate cache to get latest)
      conversationHistoryCache = null;
      const fetchedConversations = await fetchConversationsForHistory();
      console.log(
        "[WIDGET] ✅ Fetched",
        fetchedConversations.length,
        "conversations from backend"
      );

      // Update conversation history in memory
      conversationHistory = fetchedConversations;

      historyList.innerHTML = "";

      if (conversationHistory.length === 0) {
        historyList.classList.add("empty-state");
        historyList.innerHTML = `
          <div class="chatbot-history-empty">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-square-off-icon lucide-message-square-off chatbot-history-empty-icon">
              <path d="M19 19H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.7.7 0 0 1 2 21.286V5a2 2 0 0 1 1.184-1.826"/>
              <path d="m2 2 20 20"/>
              <path d="M8.656 3H20a2 2 0 0 1 2 2v11.344"/>
            </svg>
            <div class="chatbot-history-empty-text">No recent chats</div>
          </div>
        `;
        return;
      }

      // Remove empty-state class when there are conversations
      historyList.classList.remove("empty-state");

      conversationHistory.forEach((conversation) => {
        const item = document.createElement("div");
        item.className = `chatbot-history-item ${
          conversation.status === "closed" ? "closed" : ""
        }`;

        const avatar = document.createElement("div");
        avatar.className = "chatbot-history-item-avatar";
        avatar.textContent = (widgetConfig?.name || "C")[0].toUpperCase();

        const content = document.createElement("div");
        content.className = "chatbot-history-item-content";

        const title = document.createElement("div");
        title.className = "chatbot-history-item-title";
        title.textContent = conversation.title || "New conversation";

        const meta = document.createElement("div");
        meta.className = "chatbot-history-item-meta";
        const updatedDate = new Date(conversation.updated_at);
        meta.textContent = `${
          widgetConfig?.name || "Chatbot"
        } • ${getRelativeTime(updatedDate)}`;

        content.appendChild(title);
        content.appendChild(meta);

        const arrow = document.createElement("div");
        arrow.className = "chatbot-history-item-arrow";
        arrow.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>`;

        item.appendChild(avatar);
        item.appendChild(content);
        item.appendChild(arrow);

        // Allow clicking on all conversations (including closed ones) to view them
        item.addEventListener("click", async () => {
          console.log("[WIDGET] Clicked on conversation:", conversation.uuid);
          if (await loadConversation(conversation.uuid)) {
            closeMenuDropdown();
          }
        });

        historyList.appendChild(item);
      });
    } catch (error) {
      console.error("[WIDGET] ❌ Error rendering history list:", error);
      historyList.innerHTML = `
        <div class="chatbot-history-empty">
          <div class="chatbot-history-empty-text">Error loading conversations</div>
        </div>
      `;
    }
  }

  // Add message to DOM (without adding to messages array)
  function addMessageToDOM(
    role,
    content,
    agentName = null,
    messageId = null,
    timestamp = null
  ) {
    const messagesContainer = document.getElementById("chatbot-messages");
    if (!messagesContainer) return;

    const messageDiv = document.createElement("div");
    messageDiv.className = `chatbot-message ${role}`;

    if (role === "assistant" || role === "agent") {
      const messageWrapper = document.createElement("div");
      messageWrapper.className = "chatbot-message-wrapper";
      messageWrapper.style.display = "flex";
      messageWrapper.style.flexDirection = "column";
      messageWrapper.style.alignItems = "flex-start";

      const contentDiv = document.createElement("div");
      contentDiv.className = "chatbot-message-content";

      const headerDiv = document.createElement("div");
      headerDiv.className = "chatbot-message-header";

      const avatar = document.createElement("img");
      avatar.className = "chatbot-message-avatar";
      const apiUrl = getApiUrl();
      const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
      avatar.src = `${baseUrl}/chat-logo.png`;
      avatar.alt = role === "agent" ? "Agent" : "Bot";

      const nameDiv = document.createElement("div");
      nameDiv.className = "chatbot-message-name";
      if (role === "agent" && agentName) {
        nameDiv.textContent = agentName;
      } else if (role === "agent") {
        nameDiv.textContent = "Agent";
      } else {
        nameDiv.textContent = widgetConfig?.name || "Chatbot";
      }

      headerDiv.appendChild(avatar);
      headerDiv.appendChild(nameDiv);

      const textDiv = document.createElement("div");
      textDiv.className = "chatbot-message-text";
      textDiv.innerHTML = renderMarkdown(content);

      contentDiv.appendChild(headerDiv);
      contentDiv.appendChild(textDiv);

      if (window.chatbotStyling) {
        const colors = getCurrentColors(window.chatbotStyling);
        contentDiv.style.backgroundColor = colors.colorBotMessage;
        const radius = `${colors.borderRadiusMessages}px`;
        contentDiv.style.borderTopLeftRadius = radius;
        contentDiv.style.borderTopRightRadius = radius;
        contentDiv.style.borderBottomLeftRadius = "0";
        contentDiv.style.borderBottomRightRadius = radius;
      }

      messageWrapper.appendChild(contentDiv);

      if (messageId && role === "assistant") {
        const feedbackDiv = document.createElement("div");
        feedbackDiv.className = "chatbot-message-feedback";
        feedbackDiv.style.display = "flex";
        feedbackDiv.style.alignItems = "center";
        feedbackDiv.style.gap = "8px";
        feedbackDiv.style.marginTop = "8px";
        feedbackDiv.style.fontSize = "12px";
        feedbackDiv.style.color = "#6b7280";

        const copyBtn = document.createElement("button");
        copyBtn.className = "chatbot-feedback-btn chatbot-feedback-copy";
        copyBtn.setAttribute("aria-label", "Copy message");
        copyBtn.style.background = "none";
        copyBtn.style.border = "none";
        copyBtn.style.cursor = "pointer";
        copyBtn.style.padding = "2px";
        copyBtn.style.display = "flex";
        copyBtn.style.alignItems = "center";
        copyBtn.style.justifyContent = "center";
        copyBtn.style.color = "#6b7280";
        copyBtn.style.transition = "color 0.2s";
        copyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" role="img" aria-label="copy icon" style="color: currentcolor;"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.902 16.902a4 4 0 0 0 .643-.147 5 5 0 0 0 3.21-3.21C21 12.792 21 11.861 21 10s0-2.792-.245-3.545a5 5 0 0 0-3.21-3.21C16.792 3 15.861 3 14 3s-2.792 0-3.545.245a5 5 0 0 0-3.21 3.21 4 4 0 0 0-.147.643m9.804 9.804C17 16.239 17 15.372 17 14c0-1.861 0-2.792-.245-3.545a5 5 0 0 0-3.21-3.21C12.792 7 11.861 7 10 7c-1.373 0-2.24 0-2.902.098m9.804 9.804a4 4 0 0 1-.147.643 5 5 0 0 1-3.21 3.21C12.792 21 11.861 21 10 21s-2.792 0-3.545-.245a5 5 0 0 1-3.21-3.21C3 16.792 3 15.861 3 14s0-2.792.245-3.545a5 5 0 0 1 3.21-3.21c.198-.065.407-.112.643-.147" fill="none"></path></svg>`;
        copyBtn.onmouseenter = () => {
          copyBtn.style.color = "#3b82f6";
        };
        copyBtn.onmouseleave = () => {
          copyBtn.style.color = "#6b7280";
        };
        copyBtn.onclick = () => {
          copyMessageToClipboard(content);
        };

        const thumbsUpBtn = document.createElement("button");
        thumbsUpBtn.className = "chatbot-feedback-btn chatbot-feedback-like";
        thumbsUpBtn.setAttribute("aria-label", "Like this message");
        thumbsUpBtn.style.background = "none";
        thumbsUpBtn.style.border = "none";
        thumbsUpBtn.style.cursor = "pointer";
        thumbsUpBtn.style.padding = "2px";
        thumbsUpBtn.style.display = "flex";
        thumbsUpBtn.style.alignItems = "center";
        thumbsUpBtn.style.justifyContent = "center";
        thumbsUpBtn.style.color = "#6b7280";
        thumbsUpBtn.style.transition = "color 0.2s";
        thumbsUpBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-thumbs-up"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z"/></svg>`;
        thumbsUpBtn.onmouseenter = () => {
          if (!thumbsUpBtn.classList.contains("active")) {
            thumbsUpBtn.style.color = "#10b981";
          }
        };
        thumbsUpBtn.onmouseleave = () => {
          if (!thumbsUpBtn.classList.contains("active")) {
            thumbsUpBtn.style.color = "#6b7280";
          }
        };
        thumbsUpBtn.onclick = () => {
          submitFeedback(messageId, "like");
          thumbsUpBtn.classList.add("active");
          thumbsUpBtn.style.color = "#10b981";
          thumbsDownBtn.classList.remove("active");
          thumbsDownBtn.style.color = "#6b7280";
        };

        const thumbsDownBtn = document.createElement("button");
        thumbsDownBtn.className =
          "chatbot-feedback-btn chatbot-feedback-dislike";
        thumbsDownBtn.setAttribute("aria-label", "Dislike this message");
        thumbsDownBtn.style.background = "none";
        thumbsDownBtn.style.border = "none";
        thumbsDownBtn.style.cursor = "pointer";
        thumbsDownBtn.style.padding = "2px";
        thumbsDownBtn.style.display = "flex";
        thumbsDownBtn.style.alignItems = "center";
        thumbsDownBtn.style.justifyContent = "center";
        thumbsDownBtn.style.color = "#6b7280";
        thumbsDownBtn.style.transition = "color 0.2s";
        thumbsDownBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-thumbs-down"><path d="M17 14V2"/><path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z"/></svg>`;
        thumbsDownBtn.onmouseenter = () => {
          if (!thumbsDownBtn.classList.contains("active")) {
            thumbsDownBtn.style.color = "#ef4444";
          }
        };
        thumbsDownBtn.onmouseleave = () => {
          if (!thumbsDownBtn.classList.contains("active")) {
            thumbsDownBtn.style.color = "#6b7280";
          }
        };
        thumbsDownBtn.onclick = () => {
          submitFeedback(messageId, "dislike");
          thumbsDownBtn.classList.add("active");
          thumbsDownBtn.style.color = "#ef4444";
          thumbsUpBtn.classList.remove("active");
          thumbsUpBtn.style.color = "#6b7280";
        };

        const timeDiv = document.createElement("div");
        timeDiv.className = "chatbot-message-time";
        let messageDate;
        if (timestamp) {
          if (typeof timestamp === "string") {
            let timestampStr = timestamp;
            if (
              !timestampStr.endsWith("Z") &&
              !timestampStr.match(/[+-]\d{2}:\d{2}$/)
            ) {
              timestampStr = timestampStr + "Z";
            }
            messageDate = new Date(timestampStr);
          } else {
            messageDate = new Date(timestamp);
          }
        } else {
          messageDate = new Date();
        }
        timeDiv.dataset.timestamp = messageDate.getTime();
        timeDiv.textContent = getRelativeTime(messageDate);
        timeDiv.style.fontSize = "12px";
        timeDiv.style.color = "#6b7280";

        feedbackDiv.appendChild(copyBtn);
        feedbackDiv.appendChild(thumbsUpBtn);
        feedbackDiv.appendChild(thumbsDownBtn);
        feedbackDiv.appendChild(timeDiv);
        messageWrapper.appendChild(feedbackDiv);
      } else {
        const timeDiv = document.createElement("div");
        timeDiv.className = "chatbot-message-time";
        let messageDate;
        if (timestamp) {
          if (typeof timestamp === "string") {
            let timestampStr = timestamp;
            if (
              !timestampStr.endsWith("Z") &&
              !timestampStr.match(/[+-]\d{2}:\d{2}$/)
            ) {
              timestampStr = timestampStr + "Z";
            }
            messageDate = new Date(timestampStr);
          } else {
            messageDate = new Date(timestamp);
          }
        } else {
          messageDate = new Date();
        }
        timeDiv.dataset.timestamp = messageDate.getTime();
        timeDiv.textContent = getRelativeTime(messageDate);
        timeDiv.style.fontSize = "12px";
        timeDiv.style.color = "#6b7280";
        timeDiv.style.marginTop = "8px";
        messageWrapper.appendChild(timeDiv);
      }

      messageDiv.appendChild(messageWrapper);
    } else {
      const contentDiv = document.createElement("div");
      contentDiv.className = "chatbot-message-content";
      contentDiv.textContent = content;

      if (window.chatbotStyling) {
        const colors = getCurrentColors(window.chatbotStyling);
        contentDiv.style.backgroundColor = colors.colorUserMessage;
        const radius = `${colors.borderRadiusMessages}px`;
        contentDiv.style.borderTopLeftRadius = radius;
        contentDiv.style.borderTopRightRadius = radius;
        contentDiv.style.borderBottomLeftRadius = radius;
        contentDiv.style.borderBottomRightRadius = "0";
      }

      messageDiv.appendChild(contentDiv);
    }

    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  // Toggle menu dropdown
  function toggleMenuDropdown() {
    const dropdown = document.getElementById("chatbot-menu-dropdown");
    if (dropdown) {
      const isVisible = dropdown.style.display !== "none";
      dropdown.style.display = isVisible ? "none" : "block";
    }
  }

  // Close menu dropdown
  function closeMenuDropdown() {
    const dropdown = document.getElementById("chatbot-menu-dropdown");
    if (dropdown) {
      dropdown.style.display = "none";
    }
  }

  // Get API URL from script tag or use default
  function getApiUrl() {
    // Try to find the script tag that loaded this widget
    const scripts = document.querySelectorAll(
      "script[data-api-url], script[data-chatbot-uuid]"
    );
    for (const script of scripts) {
      const apiUrl = script.getAttribute("data-api-url");
      if (apiUrl) return apiUrl;
    }
    return DEFAULT_API_URL;
  }

  // Get chatbot UUID from script tag
  function getChatbotUuid() {
    // Try to find the script tag that loaded this widget
    const scripts = document.querySelectorAll("script[data-chatbot-uuid]");
    for (const script of scripts) {
      const uuid = script.getAttribute("data-chatbot-uuid");
      if (uuid) return uuid;
    }
    return null;
  }

  // Create widget HTML structure
  function createWidgetHTML() {
    const widgetContainer = document.createElement("div");
    widgetContainer.id = "chatbot-widget-container";

    const apiUrl = getApiUrl();
    // Remove trailing slash if present
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
    const logoUrl = `${baseUrl}/chat-logo.png`;

    widgetContainer.innerHTML = `
      <div id="chatbot-widget" class="chatbot-widget">
        <!-- Chat Window -->
        <div id="chatbot-window" class="chatbot-window" style="display: none;">
          <div class="chatbot-header">
            <div class="chatbot-header-content">
              <img id="chatbot-header-logo" src="${logoUrl}" alt="Bot" class="chatbot-avatar-small" style="width: 30px; height: 30px; border-radius: 50%; margin-right: 10px; background: #f9fafb; border: 1px solid rgba(255, 255, 255, 0.2); object-fit: cover; cursor: pointer;" />
              <div class="chatbot-title">${
                widgetConfig?.name || "Chatbot"
              }</div>
            </div>
            <div class="chatbot-header-actions">
              <button id="chatbot-menu-button" class="chatbot-menu-button" aria-label="Menu">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-ellipsis-icon lucide-ellipsis">
                  <circle cx="12" cy="12" r="1"/>
                  <circle cx="19" cy="12" r="1"/>
                  <circle cx="5" cy="12" r="1"/>
                </svg>
              </button>
              <div id="chatbot-menu-dropdown" class="chatbot-menu-dropdown" style="display: none;">
                <button id="chatbot-menu-history" class="chatbot-menu-item">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock5-icon lucide-clock-5">
                    <path d="M12 6v6l2 4"/>
                    <circle cx="12" cy="12" r="10"/>
                  </svg>
                  <span>Recent chats</span>
                </button>
                <button id="chatbot-menu-new-chat" class="chatbot-menu-item">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-circle-plus-icon lucide-message-circle-plus">
                    <path d="M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719"/>
                    <path d="M8 12h8"/>
                    <path d="M12 8v8"/>
                  </svg>
                  <span>Start a new chat</span>
                </button>
                <button id="chatbot-menu-end-chat" class="chatbot-menu-item">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-circle-x-icon lucide-message-circle-x">
                    <path d="M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719"/>
                    <path d="m15 9-6 6"/>
                    <path d="m9 9 6 6"/>
                  </svg>
                  <span>End chat</span>
                </button>
              </div>
            </div>
          </div>
          
          <div id="chatbot-messages" class="chatbot-messages">
            <div class="chatbot-welcome">
              <div class="chatbot-welcome-header">
                <img src="${logoUrl}" alt="Bot" class="chatbot-avatar" />
                <div class="chatbot-welcome-name">${
                  widgetConfig?.name || "Chatbot"
                }</div>
              </div>
              <div class="chatbot-welcome-text">${
                widgetConfig?.welcomeMessage || "Hi! What can I help you with?"
              }</div>
            </div>
            
            <div id="chatbot-typing" class="chatbot-typing" style="display: none;">
              <div class="typing-indicator-container">
                <div class="chatbot-message-header">
              <img src="${logoUrl}" alt="Bot" class="chatbot-message-avatar" />
                  <span class="chatbot-message-name">${
                    widgetConfig?.name || "Chatbot"
                  }</span>
                </div>
              <div class="typing-indicator">
                  <svg xmlns="http://www.w3.org/2000/svg" width="32" height="24" viewBox="0 0 32 24" fill="currentColor">
                    <circle cx="6" cy="12" r="4.2">
                      <animate attributeName="cy" values="12;8;12" dur="1.2s" repeatCount="indefinite" begin="0s"/>
                      <animate attributeName="fill-opacity" values="0.4;1;0.4" dur="1.2s" repeatCount="indefinite" begin="0s"/>
                    </circle>
                    <circle cx="16" cy="12" r="4.2">
                      <animate attributeName="cy" values="12;8;12" dur="1.2s" repeatCount="indefinite" begin="0.2s"/>
                      <animate attributeName="fill-opacity" values="0.4;1;0.4" dur="1.2s" repeatCount="indefinite" begin="0.2s"/>
                    </circle>
                    <circle cx="26" cy="12" r="4.2">
                      <animate attributeName="cy" values="12;8;12" dur="1.2s" repeatCount="indefinite" begin="0.4s"/>
                      <animate attributeName="fill-opacity" values="0.4;1;0.4" dur="1.2s" repeatCount="indefinite" begin="0.4s"/>
                    </circle>
                  </svg>
                </div>
              </div>
            </div>
            
            <div id="chatbot-history-container" class="chatbot-history-container">
              <div id="chatbot-history-list" class="chatbot-history-list"></div>
            </div>
          </div>
          
          <div class="chatbot-examples-separator"></div>
          <div id="chatbot-examples" class="chatbot-examples" style="display: none;"></div>
          
          <div class="chatbot-input-container">
            <div class="chatbot-input-wrapper">
              <textarea 
                id="chatbot-input" 
                class="chatbot-input" 
                placeholder="Ask a question..." 
                autocomplete="off"
                aria-label="Type your message"
                rows="1"
              ></textarea>
              <button id="chatbot-send" class="chatbot-send" aria-label="Send message">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                  <title>Send</title>
                  <path d="M7.94923 12.0508L3.38619 9.56218C2.19533 8.9127 2.20714 7.20057 3.40673 6.58403C6.71485 4.8838 10.2325 3.6213 13.8716 2.82811C14.9165 2.60037 16.1107 2.13611 16.9873 3.01273C17.8639 3.88934 17.3996 5.08353 17.1719 6.12843C16.3787 9.76753 15.1162 13.2851 13.416 16.5933C12.7994 17.7929 11.0873 17.8047 10.4378 16.6138L7.94923 12.0508ZM7.94923 12.0508L10.7064 9.29359" fill="none"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
        
        <!-- Popup Messages -->
        <div id="chatbot-popup-messages" class="chatbot-popup-messages" style="display: none;"></div>
        
        <!-- Floating Button -->
        <button id="chatbot-button" class="chatbot-button" aria-label="Toggle chat">
          <svg id="chatbot-button-icon-open" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
          </svg>
          <svg id="chatbot-button-icon-close" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
            <path d="m6 9 6 6 6-6"/>
          </svg>
        </button>
      </div>
    `;

    return widgetContainer;
  }

  // Inject CSS styles
  function injectStyles() {
    const style = document.createElement("style");
    style.textContent = `
      #chatbot-widget-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }
      
      .chatbot-widget {
        position: relative;
      }
      
      .chatbot-button {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: ${DEFAULT_COLORS.primary};
        color: #fff;
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s, box-shadow 0.2s;
        position: relative;
      }
      
      .chatbot-button svg {
        transition: opacity 0.2s;
      }
      
      .chatbot-button:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
      }
      
      .chatbot-button:active {
        transform: scale(0.95);
      }
      
      .chatbot-window {
        position: absolute;
        bottom: 80px;
        right: 0;
        width: 380px;
        max-width: calc(100vw - 40px);
        height: 600px;
        max-height: calc(100vh - 100px);
        background: #fff;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        display: none;
        flex-direction: column;
        overflow: hidden;
      }
      
      .chatbot-popup-messages {
        position: absolute;
        bottom: 80px;
        right: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: flex-end;
        pointer-events: none;
        z-index: 9998;
        max-width: calc(100vw - 100px);
      }
      
      .chatbot-popup-message {
        background: #fff;
        color: #111827;
        padding: 12px 18px;
        border-radius: 12px;
        font-size: 15px;
        max-width: 320px;
        width: max-content;
        word-wrap: break-word;
        animation: popupFadeIn 0.3s ease-out;
        pointer-events: auto;
        border: 1px solid rgba(0, 0, 0, 0.1);
        line-height: 1.5;
      }
      
      @keyframes popupFadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .chatbot-header {
        background: ${DEFAULT_COLORS.primary};
        color: #fff;
        padding: 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .chatbot-header-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .chatbot-logo {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #000;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
      }
      
      .chatbot-title {
        font-weight: 600;
        font-size: 16px;
      }
      
      .chatbot-header-actions {
        position: relative;
      }
      
      .chatbot-menu-button {
        background: none;
        border: none;
        color: #fff;
        cursor: pointer;
        padding: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      
      .chatbot-menu-button:hover {
        opacity: 1;
      }
      
      .chatbot-menu-dropdown {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        min-width: 200px;
        z-index: 10000;
        overflow: hidden;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }
      
      .chatbot-menu-item {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: none;
        border: none;
        cursor: pointer;
        color: #111827;
        font-size: 14px;
        text-align: left;
        transition: background-color 0.2s;
      }
      
      .chatbot-menu-item:hover {
        background: #f3f4f6;
      }
      
      .chatbot-menu-item svg {
        flex-shrink: 0;
        color: #6b7280;
      }
      
      .chatbot-menu-item:hover svg {
        color: #111827;
      }
      
      .chatbot-history-container {
        display: none;
        flex-direction: column;
        height: 100%;
        overflow-y: auto;
      }
      
      .chatbot-history-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px 0;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      
      .chatbot-history-list.empty-state {
        justify-content: center;
        align-items: center;
      }
      
      .chatbot-history-item {
        padding: 12px 20px;
        border-bottom: 1px solid #f3f4f6;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .chatbot-history-item:hover {
        background: #f9fafb;
      }
      
      .chatbot-history-item.closed {
        opacity: 0.6;
      }
      
      .chatbot-history-item-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #000;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        flex-shrink: 0;
      }
      
      .chatbot-history-item-content {
        flex: 1;
        min-width: 0;
      }
      
      .chatbot-history-item-title {
        font-weight: 500;
        font-size: 14px;
        color: #111827;
        margin-bottom: 4px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      .chatbot-history-item-meta {
        font-size: 12px;
        color: #6b7280;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      
      .chatbot-history-item-arrow {
        color: #9ca3af;
        flex-shrink: 0;
      }
      
      .chatbot-history-empty {
        padding: 40px 20px;
        text-align: center;
        color: #6b7280;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 12px;
        width: 100%;
        flex: 1;
      }
      
      .chatbot-history-empty-icon {
        color: #9ca3af;
        flex-shrink: 0;
      }
      
      .chatbot-history-empty-text {
        font-size: 18px;
        color: #6b7280;
        font-weight: 500;
      }
      
      .chatbot-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      
      .chatbot-welcome {
        padding: 12px 16px;
        max-width: 75%;
      }
      
      .chatbot-welcome-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 5px;
      }
      
      .chatbot-avatar {
        width: 26px;
        height: 26px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
      
      .chatbot-welcome-name {
        font-weight: 600;
        font-size: 14px;
        color: #1f2937;
        margin: 0;
      }
      
      .chatbot-welcome-text {
        font-size: 14px;
        color: #374151;
        line-height: 1.5;
        margin: 0;
      }
      
      .chatbot-examples-separator {
        margin: 0 16px;
      }
      
      .chatbot-examples {
        position: relative;
        margin-left: auto;
        display: flex;
        flex-wrap: wrap-reverse;
        justify-content: flex-end;
        align-content: flex-start;
        gap: 8px;
        padding: 12px 20px 16px 20px;
        max-height: 136px;
        overflow: hidden;
        width: 100%;
      }
      
      .chatbot-example-wrapper {
        overflow: hidden;
      }
      
      .chatbot-example-button {
        display: flex;
        align-items: center;
        justify-content: center;
        height: auto;
        min-height: 40px;
        max-width: 40ch;
        border-radius: 30px;
        border: 1px solid #e5e7eb;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 500;
        background: #fff;
        color: #000;
        cursor: pointer;
        transition: all 0.2s;
        white-space: normal;
        word-wrap: break-word;
        hyphens: auto;
        box-shadow: none;
        outline: none;
        text-align: center;
      }
      
      .chatbot-example-button:hover {
        background: #000;
        color: #fff;
        border-color: #000;
      }
      
      .chatbot-example-button:active {
        transform: scale(0.98);
      }
      
      .chatbot-example-button:focus-visible {
        outline: 2px solid #000;
        outline-offset: 2px;
      }
      
      .chatbot-message {
        display: flex;
        animation: fadeIn 0.3s;
        align-items: flex-start;
        margin-bottom: 8px;
      }
      
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .chatbot-message.user {
        justify-content: flex-end;
      }
      
      .chatbot-message.assistant {
        justify-content: flex-start;
      }
      
      .chatbot-message-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 5px;
      }
      
      .chatbot-message-avatar {
        width: 26px;
        height: 26px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
      
      .chatbot-message-content {
        padding: 12px 16px;
        line-height: 1.5;
        word-wrap: break-word;
        word-break: break-word;
        max-width: 95%;
        font-size: 14px;
      }
      
      .chatbot-message.assistant .chatbot-message-content {
        color: #111827;
        padding: 12px 16px;
        min-width: 200px;
      }
      
      .chatbot-message.agent .chatbot-message-content {
        min-width: 200px;
      }
      
      .chatbot-message-name {
        font-weight: 600;
        font-size: 14px;
        color: #111827;
        margin: 0;
      }
      
      .chatbot-message-text {
        font-size: 14px;
        color: #374151;
        line-height: 1.5;
        word-wrap: break-word;
        margin: 0;
      }
      
      .chatbot-message-text ul {
        margin: 8px 0;
        padding-left: 20px;
        list-style-type: disc;
      }
      
      .chatbot-message-text li {
        margin: 4px 0;
        line-height: 1.6;
      }
      
      .chatbot-message-text p {
        margin: 4px 0;
      }
      
      .chatbot-message-text p:first-child {
        margin-top: 0;
      }
      
      .chatbot-message-text p:last-child {
        margin-bottom: 0;
      }
      
      .chatbot-message-text strong {
        font-weight: 600;
      }
      
      .chatbot-message-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        max-width: 90%;
        min-width: 200px;
      }
      
      .chatbot-message-time {
        font-size: 11px;
        color: #9ca3af;
        margin-top: 4px;
        margin-bottom: 0;
        padding-left: 0;
      }
      
      .chatbot-message.user .chatbot-message-content {
        color: #fff;
        max-width: none;
        width: fit-content;
      }
      
      .chatbot-typing {
        display: flex;
        align-items: flex-start;
      }
      
      .typing-indicator-container {
        padding: 12px 16px;
        max-width: 75%;
      }
      
      .typing-indicator {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        margin-top: 4px;
      }
      
      .typing-indicator svg {
        color: #9ca3af;
        display: block;
      }
      
      .chatbot-input-container {
        padding: 16px;
        border-top: 1px solid #e5e7eb;
      }
      
      .chatbot-input-wrapper {
        position: relative;
        display: flex;
        align-items: flex-end;
        border: 1px solid #d1d5db;
        border-radius: 24px;
        background: #fff;
        padding: 8px;
        gap: 8px;
      }
      
      .chatbot-input-wrapper:focus-within {
        border-color: #000;
      }
      
      .chatbot-input {
        flex: 1;
        padding: 4px 8px;
        border: none;
        font-size: 14px;
        outline: none;
        background: transparent;
        resize: none;
        overflow-y: auto;
        overflow-x: hidden;
        min-height: 28px;
        max-height: 150px;
        line-height: 1.5;
        font-family: inherit;
        box-sizing: border-box;
      }
      
      .chatbot-input::-webkit-scrollbar {
        width: 6px;
      }
      
      .chatbot-input::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .chatbot-input::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }
      
      .chatbot-input::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      
      .chatbot-send {
        flex-shrink: 0;
        width: 28px;
        height: 28px;
        background: none;
        color: #9ca3af;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s;
        padding: 0;
        border-radius: 4px;
      }
      
      .chatbot-send:hover:not(:disabled) {
        color: #000;
      }
      
      .chatbot-send:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }
      
      @media (max-width: 480px) {
        .chatbot-window {
          width: calc(100vw - 20px);
          height: calc(100vh - 20px);
          bottom: 10px;
          right: 10px;
        }
        
        #chatbot-widget-container {
          bottom: 10px;
          right: 10px;
        }
        
        .chatbot-popup-message {
          max-width: calc(100vw - 100px);
        }
      }
    `;
    document.head.appendChild(style);
  }

  // Connect to WebSocket
  function connectWebSocket() {
    if (!widgetConfig || !sessionId) return;

    // Prevent multiple simultaneous connections
    if (isConnecting) {
      console.log(
        "[WIDGET] ⚠️ WebSocket connection already in progress, skipping"
      );
      return;
    }

    // Close existing connection if any
    if (websocket) {
      if (
        websocket.readyState === WebSocket.OPEN ||
        websocket.readyState === WebSocket.CONNECTING
      ) {
        console.log("[WIDGET] Closing existing WebSocket connection");
        websocket.onclose = null; // Prevent reconnection attempt
        websocket.close();
      }
      websocket = null;
    }

    isConnecting = true;

    const apiUrl = getApiUrl();
    // Extract host and protocol
    let wsProtocol = "ws";
    let host = apiUrl;

    if (apiUrl.startsWith("https://")) {
      wsProtocol = "wss";
      host = apiUrl.replace("https://", "");
    } else if (apiUrl.startsWith("http://")) {
      wsProtocol = "ws";
      host = apiUrl.replace("http://", "");
    }

    // Get client_uuid from localStorage if it exists
    const clientUuid = getClientUuid();
    let wsUrl = `${wsProtocol}://${host}/api/chat/ws/${widgetConfig.uuid}?session_id=${sessionId}`;
    if (clientUuid) {
      wsUrl += `&client_uuid=${encodeURIComponent(clientUuid)}`;
      console.log("[WIDGET] Connecting with existing client_uuid:", clientUuid);
    } else {
      console.log(
        "[WIDGET] Connecting without client_uuid (will receive one after first message)"
      );
    }

    try {
      websocket = new WebSocket(wsUrl);

      websocket.onopen = () => {
        isConnecting = false;
        reconnectAttempts = 0;
        console.log("WebSocket connected");
      };

      websocket.onmessage = (event) => {
        console.log("[WIDGET] ✅ Received WebSocket message:", event.data);
        const data = JSON.parse(event.data);
        console.log("[WIDGET] Parsed data:", data);
        handleWebSocketMessage(data);
      };

      websocket.onerror = (error) => {
        isConnecting = false;
        console.error("WebSocket error:", error);
      };

      websocket.onclose = (event) => {
        isConnecting = false;
        console.log("WebSocket closed", event.code, event.reason);

        // Don't reconnect if closed due to chatbot not found or inactive
        if (event.code === 4004 || event.code === 4003 || event.code === 4005) {
          console.error("WebSocket closed permanently:", event.reason);
          addMessage(
            "assistant",
            "Sorry, the chatbot is not available. Please check the chatbot configuration."
          );
          return;
        }

        // Attempt to reconnect only for unexpected closures
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS && isOpen) {
          reconnectAttempts++;
          console.log(
            `Reconnecting in ${
              1000 * reconnectAttempts
            }ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`
          );
          setTimeout(() => {
            connectWebSocket();
          }, 1000 * reconnectAttempts);
        } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          addMessage(
            "assistant",
            "Connection lost. Please refresh the page to try again."
          );
        }
      };
    } catch (error) {
      isConnecting = false;
      console.error("Failed to connect WebSocket:", error);
    }
  }

  // Get or create typing indicator element
  function getTypingIndicator() {
    let typingIndicator = document.getElementById("chatbot-typing");
    if (!typingIndicator) {
      // Create typing indicator if it doesn't exist
      const messagesContainer = document.getElementById("chatbot-messages");
      if (messagesContainer) {
        typingIndicator = document.createElement("div");
        typingIndicator.id = "chatbot-typing";
        typingIndicator.className = "chatbot-typing";
        typingIndicator.style.display = "none";

        const apiUrl = getApiUrl();
        const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
        const logoUrl = widgetConfig?.logo || `${baseUrl}/chat-logo.png`;
        typingIndicator.innerHTML = `
          <div class="typing-indicator-container">
            <div class="chatbot-message-header">
              <img src="${logoUrl}" alt="Bot" class="chatbot-message-avatar" />
              <span class="chatbot-message-name">${
                widgetConfig?.name || "Chatbot"
              }</span>
            </div>
            <div class="typing-indicator">
              <svg xmlns="http://www.w3.org/2000/svg" width="32" height="24" viewBox="0 0 32 24" fill="currentColor">
                <circle cx="6" cy="12" r="4.2">
                  <animate attributeName="cy" values="12;8;12" dur="1.2s" repeatCount="indefinite" begin="0s"/>
                  <animate attributeName="fill-opacity" values="0.4;1;0.4" dur="1.2s" repeatCount="indefinite" begin="0s"/>
                </circle>
                <circle cx="16" cy="12" r="4.2">
                  <animate attributeName="cy" values="12;8;12" dur="1.2s" repeatCount="indefinite" begin="0.2s"/>
                  <animate attributeName="fill-opacity" values="0.4;1;0.4" dur="1.2s" repeatCount="indefinite" begin="0.2s"/>
                </circle>
                <circle cx="26" cy="12" r="4.2">
                  <animate attributeName="cy" values="12;8;12" dur="1.2s" repeatCount="indefinite" begin="0.4s"/>
                  <animate attributeName="fill-opacity" values="0.4;1;0.4" dur="1.2s" repeatCount="indefinite" begin="0.4s"/>
                </circle>
              </svg>
            </div>
          </div>
        `;

        // Apply styling to the newly created typing indicator
        if (widgetConfig?.styling) {
          const colors = getCurrentColors(widgetConfig.styling);
          const typingContainer = typingIndicator.querySelector(
            ".typing-indicator-container"
          );
          if (typingContainer) {
            typingContainer.style.backgroundColor = colors.colorBotMessage;
            const radius = `${colors.borderRadiusMessages}px`;
            typingContainer.style.borderTopLeftRadius = radius;
            typingContainer.style.borderTopRightRadius = radius;
            typingContainer.style.borderBottomLeftRadius = "0";
            typingContainer.style.borderBottomRightRadius = radius;
          }
        }
      }
    } else {
      // Ensure existing typing indicator has correct styling
      if (widgetConfig?.styling) {
        const colors = getCurrentColors(widgetConfig.styling);
        const typingContainer = typingIndicator.querySelector(
          ".typing-indicator-container"
        );
        if (typingContainer) {
          typingContainer.style.backgroundColor = colors.colorBotMessage;
          const radius = `${colors.borderRadiusMessages}px`;
          typingContainer.style.borderTopLeftRadius = radius;
          typingContainer.style.borderTopRightRadius = radius;
          typingContainer.style.borderBottomLeftRadius = "0";
          typingContainer.style.borderBottomRightRadius = radius;
        }
      }
    }
    return typingIndicator;
  }

  // Handle WebSocket messages
  function handleWebSocketMessage(data) {
    console.log("[WIDGET] Handling message type:", data.type);
    const messagesContainer = document.getElementById("chatbot-messages");
    const typingIndicator = getTypingIndicator();

    // Filter messages by conversation ID if we're viewing a specific conversation
    if (
      currentConversationId &&
      data.conversation_uuid &&
      data.conversation_uuid !== currentConversationId
    ) {
      console.log(
        "[WIDGET] ⚠️ Message for different conversation, ignoring:",
        data.conversation_uuid,
        "current:",
        currentConversationId
      );
      return;
    }

    switch (data.type) {
      case "connection":
        console.log("[WIDGET] ✅ Connected to chatbot");
        break;

      case "conversation_created":
        console.log(
          "[WIDGET] ✅ Conversation created:",
          data.conversation_uuid,
          "for session:",
          data.session_id,
          "current sessionId:",
          sessionId
        );
        // CRITICAL: Only set currentConversationId if:
        // 1. We have a conversation_uuid
        // 2. The session_id matches our current sessionId (ensures it's for this new conversation)
        // 3. We don't already have a currentConversationId (prevents overwriting when loading old conversations)
        if (data.conversation_uuid && data.session_id === sessionId) {
          // Only set if we're starting a new conversation (currentConversationId is null)
          // If we're loading an old conversation, don't overwrite it
          if (!currentConversationId) {
            currentConversationId = data.conversation_uuid;
            console.log(
              "[WIDGET] ✅ Set currentConversationId to NEW conversation:",
              currentConversationId
            );

            // Store client_uuid if provided (this is the first time we get it)
            if (data.client_uuid) {
              saveClientUuid(data.client_uuid);
              console.log("[WIDGET] ✅ Stored client_uuid:", data.client_uuid);
            }

            // Ensure conversation is in history
            const existingConv = conversationHistory.find(
              (c) => c.uuid === currentConversationId
            );
            if (!existingConv) {
              const title =
                messages.length > 0
                  ? getConversationTitle()
                  : "New conversation";
              updateConversationMetadata(
                currentConversationId,
                title,
                "active",
                new Date().toISOString()
              );
            }

            // Update metadata
            if (messages.length > 0) {
              const title = getConversationTitle();
              updateConversationMetadata(
                currentConversationId,
                title,
                "active",
                new Date().toISOString()
              );
            }
          } else {
            console.log(
              "[WIDGET] ⚠️ Conversation created but we already have currentConversationId:",
              currentConversationId,
              "- ignoring (likely loading old conversation)"
            );
          }
        } else {
          console.log(
            "[WIDGET] ⚠️ Conversation created but session_id mismatch or missing data"
          );
        }
        break;

      case "typing":
        console.log("[WIDGET] Typing indicator:", data.is_typing);
        if (typingIndicator) {
          if (data.is_typing) {
            // Ensure styling is applied before showing
            if (widgetConfig?.styling) {
              const colors = getCurrentColors(widgetConfig.styling);
              const typingContainer = typingIndicator.querySelector(
                ".typing-indicator-container"
              );
              if (typingContainer) {
                typingContainer.style.backgroundColor = colors.colorBotMessage;
                const radius = `${colors.borderRadiusMessages}px`;
                typingContainer.style.borderTopLeftRadius = radius;
                typingContainer.style.borderTopRightRadius = radius;
                typingContainer.style.borderBottomLeftRadius = "0";
                typingContainer.style.borderBottomRightRadius = radius;
              }
            }
            // Move typing indicator to the bottom
            messagesContainer.appendChild(typingIndicator);
            typingIndicator.style.display = "flex";
          } else {
            typingIndicator.style.display = "none";
          }

          console.log(
            "[WIDGET] Typing indicator display:",
            typingIndicator.style.display
          );

          // Scroll to show typing indicator
          if (data.is_typing && messagesContainer) {
            setTimeout(() => {
              messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 10);
          }
        } else {
          console.error("[WIDGET] ❌ Typing indicator element not found");
        }
        break;

      case "message":
        console.log(
          "[WIDGET] Received message:",
          data.role || "assistant",
          data.content
        );
        if (typingIndicator) {
          typingIndicator.style.display = "none";
        }
        // Handle both assistant and agent messages
        const messageRole = data.role || "assistant";
        const agentName = data.agent_name || null; // Get agent name if provided
        const messageId = data.id || null; // Get message ID if provided

        // Check for duplicate messages using message ID (more reliable than content comparison)
        const isDuplicate = messageId
          ? processedMessageIds.has(messageId)
          : messages.some(
              (msg) => msg.role === messageRole && msg.content === data.content
            );

        if (!isDuplicate) {
          // Mark message as processed
          if (messageId) {
            processedMessageIds.add(messageId);
          }

          // Parse timestamp - ensure UTC handling
          let timestamp;
          if (data.timestamp) {
            // If timestamp doesn't have timezone info, assume it's UTC and add Z
            let timestampStr = data.timestamp;
            if (
              !timestampStr.endsWith("Z") &&
              !timestampStr.match(/[+-]\d{2}:\d{2}$/)
            ) {
              timestampStr = timestampStr + "Z";
            }
            timestamp = new Date(timestampStr);
          } else {
            timestamp = new Date(); // Current time
          }
          addMessage(
            messageRole,
            data.content,
            agentName,
            messageId,
            timestamp
          );
          console.log(
            "[WIDGET] ✅ Message added to UI",
            messageId ? `(ID: ${messageId})` : ""
          );
        } else {
          console.log("[WIDGET] ⚠️ Duplicate message detected, skipping");
        }
        break;

      case "message_chunk":
        // Only process chunks for current conversation
        if (
          data.conversation_uuid &&
          currentConversationId &&
          data.conversation_uuid !== currentConversationId
        ) {
          console.log("[WIDGET] ⚠️ Chunk for different conversation, ignoring");
          return;
        }

        console.log("[WIDGET] Received streaming chunk:", data.content);
        if (typingIndicator) {
          typingIndicator.style.display = "none";
        }

        // Lazily create a streaming assistant message bubble
        if (!streamingAssistantMessage) {
          streamingAssistantMessage = createStreamingAssistantMessage();
        }
        if (!streamingAssistantMessage) {
          console.error(
            "[WIDGET] ❌ Failed to create streaming assistant message"
          );
          break;
        }

        const chunkText = data.content || "";
        streamingAssistantMessage.text += chunkText;
        streamingAssistantMessage.textElement.innerHTML = renderMarkdown(
          streamingAssistantMessage.text
        );

        // Keep scrolled to bottom
        if (messagesContainer) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        break;

      case "message_complete":
        // Only process complete messages for current conversation
        if (
          data.conversation_uuid &&
          currentConversationId &&
          data.conversation_uuid !== currentConversationId
        ) {
          console.log(
            "[WIDGET] ⚠️ Message complete for different conversation, ignoring"
          );
          return;
        }

        console.log(
          "[WIDGET] Received message_complete:",
          data.content?.slice(0, 80)
        );
        if (typingIndicator) {
          typingIndicator.style.display = "none";
        }

        // Mark message as processed if it has an ID
        if (data.id) {
          processedMessageIds.add(data.id);
        }

        // If for some reason we didn't get chunks, fall back to normal addMessage
        if (!streamingAssistantMessage) {
          const fallbackTimestamp = data.timestamp
            ? new Date(data.timestamp)
            : new Date();
          addMessage(
            data.role || "assistant",
            data.content || "",
            data.agent_name || null,
            data.id || null,
            fallbackTimestamp
          );
          break;
        }

        // Ensure final text matches server content
        const finalText =
          data.content && data.content.length
            ? data.content
            : streamingAssistantMessage.text;
        streamingAssistantMessage.text = finalText;
        streamingAssistantMessage.textElement.innerHTML =
          renderMarkdown(finalText);

        // Attach feedback + timestamp, as in addMessage for assistant
        const wrapper = streamingAssistantMessage.messageDiv.querySelector(
          ".chatbot-message-wrapper"
        );
        if (wrapper) {
          const messageId = data.id || null;
          const timestamp = data.timestamp
            ? data.timestamp
            : new Date().toISOString();

          // Only add feedback section if we have a message id
          if (messageId) {
            const feedbackDiv = document.createElement("div");
            feedbackDiv.className = "chatbot-message-feedback";
            feedbackDiv.style.display = "flex";
            feedbackDiv.style.alignItems = "center";
            feedbackDiv.style.gap = "8px";
            feedbackDiv.style.marginTop = "8px";
            feedbackDiv.style.fontSize = "12px";
            feedbackDiv.style.color = "#6b7280";

            // Copy button
            const copyBtn = document.createElement("button");
            copyBtn.className = "chatbot-feedback-btn chatbot-feedback-copy";
            copyBtn.setAttribute("aria-label", "Copy message");
            copyBtn.style.background = "none";
            copyBtn.style.border = "none";
            copyBtn.style.cursor = "pointer";
            copyBtn.style.padding = "2px";
            copyBtn.style.display = "flex";
            copyBtn.style.alignItems = "center";
            copyBtn.style.justifyContent = "center";
            copyBtn.style.color = "#6b7280";
            copyBtn.style.transition = "color 0.2s";
            copyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" role="img" aria-label="copy icon" style="color: currentcolor;"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.902 16.902a4 4 0 0 0 .643-.147 5 5 0 0 0 3.21-3.21C21 12.792 21 11.861 21 10s0-2.792-.245-3.545a5 5 0 0 0-3.21-3.21C16.792 3 15.861 3 14 3s-2.792 0-3.545.245a5 5 0 0 0-3.21 3.21 4 4 0 0 0-.147.643m9.804 9.804C17 16.239 17 15.372 17 14c0-1.861 0-2.792-.245-3.545a5 5 0 0 0-3.21-3.21C12.792 7 11.861 7 10 7c-1.373 0-2.24 0-2.902.098m9.804 9.804a4 4 0 0 1-.147.643 5 5 0 0 1-3.21 3.21C12.792 21 11.861 21 10 21s-2.792 0-3.545-.245a5 5 0 0 1-3.21-3.21C3 16.792 3 15.861 3 14s0-2.792.245-3.545a5 5 0 0 1 3.21-3.21c.198-.065.407-.112.643-.147" fill="none"></path></svg>`;
            copyBtn.onmouseenter = () => {
              copyBtn.style.color = "#3b82f6";
            };
            copyBtn.onmouseleave = () => {
              copyBtn.style.color = "#6b7280";
            };
            copyBtn.onclick = () => {
              copyMessageToClipboard(finalText);
            };

            // Thumbs up / down
            const thumbsUpBtn = document.createElement("button");
            thumbsUpBtn.className =
              "chatbot-feedback-btn chatbot-feedback-like";
            thumbsUpBtn.setAttribute("aria-label", "Like this message");
            thumbsUpBtn.style.background = "none";
            thumbsUpBtn.style.border = "none";
            thumbsUpBtn.style.cursor = "pointer";
            thumbsUpBtn.style.padding = "2px";
            thumbsUpBtn.style.display = "flex";
            thumbsUpBtn.style.alignItems = "center";
            thumbsUpBtn.style.justifyContent = "center";
            thumbsUpBtn.style.color = "#6b7280";
            thumbsUpBtn.style.transition = "color 0.2s";
            thumbsUpBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-thumbs-up"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z"/></svg>`;
            thumbsUpBtn.onmouseenter = () => {
              if (!thumbsUpBtn.classList.contains("active")) {
                thumbsUpBtn.style.color = "#10b981";
              }
            };
            thumbsUpBtn.onmouseleave = () => {
              if (!thumbsUpBtn.classList.contains("active")) {
                thumbsUpBtn.style.color = "#6b7280";
              }
            };

            const thumbsDownBtn = document.createElement("button");
            thumbsDownBtn.className =
              "chatbot-feedback-btn chatbot-feedback-dislike";
            thumbsDownBtn.setAttribute("aria-label", "Dislike this message");
            thumbsDownBtn.style.background = "none";
            thumbsDownBtn.style.border = "none";
            thumbsDownBtn.style.cursor = "pointer";
            thumbsDownBtn.style.padding = "2px";
            thumbsDownBtn.style.display = "flex";
            thumbsDownBtn.style.alignItems = "center";
            thumbsDownBtn.style.justifyContent = "center";
            thumbsDownBtn.style.color = "#6b7280";
            thumbsDownBtn.style.transition = "color 0.2s";
            thumbsDownBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-thumbs-down"><path d="M17 14V2"/><path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z"/></svg>`;
            thumbsUpBtn.onclick = () => {
              submitFeedback(messageId, "like");
              thumbsUpBtn.classList.add("active");
              thumbsUpBtn.style.color = "#10b981";
              thumbsDownBtn.classList.remove("active");
              thumbsDownBtn.style.color = "#6b7280";
            };
            thumbsDownBtn.onclick = () => {
              submitFeedback(messageId, "dislike");
              thumbsDownBtn.classList.add("active");
              thumbsDownBtn.style.color = "#ef4444";
              thumbsUpBtn.classList.remove("active");
              thumbsUpBtn.style.color = "#6b7280";
            };

            // Relative time
            const timeDiv = document.createElement("div");
            timeDiv.className = "chatbot-message-time";
            let messageDate;
            if (timestamp) {
              if (typeof timestamp === "string") {
                let ts = timestamp;
                if (!ts.endsWith("Z") && !ts.match(/[+-]\d{2}:\d{2}$/)) {
                  ts = ts + "Z";
                }
                messageDate = new Date(ts);
              } else {
                messageDate = new Date(timestamp);
              }
            } else {
              messageDate = new Date();
            }
            timeDiv.dataset.timestamp = messageDate.getTime();
            timeDiv.textContent = getRelativeTime(messageDate);
            timeDiv.style.fontSize = "12px";
            timeDiv.style.color = "#6b7280";

            feedbackDiv.appendChild(copyBtn);
            feedbackDiv.appendChild(thumbsUpBtn);
            feedbackDiv.appendChild(thumbsDownBtn);
            feedbackDiv.appendChild(timeDiv);
            wrapper.appendChild(feedbackDiv);
          }

          // Track this message in the in-memory array for duplicate detection
          const messageTimestamp = data.timestamp
            ? data.timestamp
            : new Date().toISOString();
          messages.push({
            role: "assistant",
            content: finalText,
            messageId: data.id || null,
            timestamp: messageTimestamp,
          });

          // Update conversation metadata after message completes
          if (currentConversationId) {
            const title = getConversationTitle();
            updateConversationMetadata(
              currentConversationId,
              title,
              "active",
              new Date().toISOString()
            );
          }
        }

        // Clear streaming state
        streamingAssistantMessage = null;

        // Ensure scroll
        if (messagesContainer) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        break;

      case "error":
        console.error("[WIDGET] ❌ Received error:", data.message);
        if (typingIndicator) {
          typingIndicator.style.display = "none";
        }
        // Display the actual error message from the backend
        const errorMessage =
          data.message || "Sorry, I encountered an error. Please try again.";
        addMessage("assistant", errorMessage);
        break;

      default:
        console.warn("[WIDGET] ⚠️ Unknown message type:", data.type);
    }
  }

  // Display example messages
  function displayExampleMessages() {
    const examplesContainer = document.getElementById("chatbot-examples");
    if (!examplesContainer || !widgetConfig) return;

    const exampleMessages = widgetConfig.exampleMessages || [];
    if (exampleMessages.length === 0) {
      examplesContainer.style.display = "none";
      return;
    }

    examplesContainer.innerHTML = "";
    examplesContainer.style.display = "flex";

    // Reverse the array so questions appear from bottom to top (like stairs)
    const reversedMessages = [...exampleMessages].reverse();

    reversedMessages.forEach((msg) => {
      // Create wrapper div
      const wrapper = document.createElement("div");
      wrapper.className = "chatbot-example-wrapper";

      // Create button
      const button = document.createElement("button");
      button.className = "chatbot-example-button";
      button.type = "button";
      button.setAttribute("aria-label", msg);
      button.setAttribute("title", msg);
      button.textContent = msg;
      button.addEventListener("click", () => {
        // Set input value and send message
        const input = document.getElementById("chatbot-input");
        if (input) {
          input.value = msg;
          sendMessage();
        }
      });

      wrapper.appendChild(button);
      examplesContainer.appendChild(wrapper);
    });
  }

  // Add message to chat
  // Simple markdown renderer for messages
  function renderMarkdown(text) {
    if (!text) return "";

    // Escape HTML first to prevent XSS
    let html = text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");

    // Convert markdown links [text](url) to <a> tags
    html = html.replace(
      /\[([^\]]+)\]\(([^)]+)\)/g,
      '<a href="$2" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline;">$1</a>'
    );

    // Convert markdown bold **text** to <strong>text</strong>
    html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

    // Convert markdown bullets (- or *) to HTML list
    // Split by lines and process
    const lines = html.split("\n");
    const processedLines = [];
    let inList = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const isBullet = /^[-*]\s+/.test(line);

      if (isBullet) {
        if (!inList) {
          processedLines.push("<ul>");
          inList = true;
        }
        // Remove the bullet marker and wrap in <li>
        const listItem = line.replace(/^[-*]\s+/, "");
        processedLines.push(`<li>${listItem}</li>`);
      } else {
        if (inList) {
          processedLines.push("</ul>");
          inList = false;
        }
        if (line) {
          processedLines.push(`<p>${line}</p>`);
        } else {
          processedLines.push("<br>");
        }
      }
    }

    // Close any open list
    if (inList) {
      processedLines.push("</ul>");
    }

    return processedLines.join("");
  }

  function addMessage(
    role,
    content,
    agentName = null,
    messageId = null,
    timestamp = null
  ) {
    const messagesContainer = document.getElementById("chatbot-messages");
    if (!messagesContainer) return;

    // Remove welcome message if it exists
    const welcome = messagesContainer.querySelector(".chatbot-welcome");
    if (welcome) {
      welcome.remove();
    }

    // Hide examples if they exist (they're outside the messages container now)
    const examples = document.getElementById("chatbot-examples");
    if (examples) {
      examples.style.display = "none";
    }
    const examplesSeparator = document.querySelector(
      ".chatbot-examples-separator"
    );
    if (examplesSeparator) {
      examplesSeparator.style.display = "none";
    }

    const messageDiv = document.createElement("div");
    messageDiv.className = `chatbot-message ${role}`;

    if (role === "assistant" || role === "agent") {
      // Create wrapper for content and timestamp
      const messageWrapper = document.createElement("div");
      messageWrapper.className = "chatbot-message-wrapper";
      messageWrapper.style.display = "flex";
      messageWrapper.style.flexDirection = "column";
      messageWrapper.style.alignItems = "flex-start";

      // Add message content with avatar and name inside
      const contentDiv = document.createElement("div");
      contentDiv.className = "chatbot-message-content";

      // Create header with avatar and name
      const headerDiv = document.createElement("div");
      headerDiv.className = "chatbot-message-header";

      const avatar = document.createElement("img");
      avatar.className = "chatbot-message-avatar";

      // Use different styling for agent vs assistant
      if (role === "agent") {
        // For human agents, use a person icon or different styling
        const apiUrl = getApiUrl();
        const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
        avatar.src = `${baseUrl}/chat-logo.png`; // You can change this to a person icon
        avatar.alt = "Agent";
      } else {
        const apiUrl = getApiUrl();
        const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
        avatar.src = `${baseUrl}/chat-logo.png`;
        avatar.alt = "Bot";
      }

      const nameDiv = document.createElement("div");
      nameDiv.className = "chatbot-message-name";
      // Use agent name if provided, otherwise use chatbot name or fallback
      if (role === "agent" && agentName) {
        nameDiv.textContent = agentName;
      } else if (role === "agent") {
        nameDiv.textContent = "Agent";
      } else {
        const chatbotName = widgetConfig?.name || "Chatbot";
        nameDiv.textContent = chatbotName;
      }

      headerDiv.appendChild(avatar);
      headerDiv.appendChild(nameDiv);

      const textDiv = document.createElement("div");
      textDiv.className = "chatbot-message-text";
      textDiv.innerHTML = renderMarkdown(content);

      contentDiv.appendChild(headerDiv);
      contentDiv.appendChild(textDiv);

      // Apply styling if available
      if (window.chatbotStyling) {
        const colors = getCurrentColors(window.chatbotStyling);
        contentDiv.style.backgroundColor = colors.colorBotMessage;
        const radius = `${colors.borderRadiusMessages}px`;
        // Remove bottom-left corner (corner closest to input)
        contentDiv.style.borderTopLeftRadius = radius;
        contentDiv.style.borderTopRightRadius = radius;
        contentDiv.style.borderBottomLeftRadius = "0";
        contentDiv.style.borderBottomRightRadius = radius;
      }

      messageWrapper.appendChild(contentDiv);

      // Add feedback section for assistant messages (only if messageId is provided)
      if (messageId && role === "assistant") {
        const feedbackDiv = document.createElement("div");
        feedbackDiv.className = "chatbot-message-feedback";
        feedbackDiv.style.display = "flex";
        feedbackDiv.style.alignItems = "center";
        feedbackDiv.style.gap = "8px";
        feedbackDiv.style.marginTop = "8px";
        feedbackDiv.style.fontSize = "12px";
        feedbackDiv.style.color = "#6b7280";

        // Copy button
        const copyBtn = document.createElement("button");
        copyBtn.className = "chatbot-feedback-btn chatbot-feedback-copy";
        copyBtn.setAttribute("aria-label", "Copy message");
        copyBtn.style.background = "none";
        copyBtn.style.border = "none";
        copyBtn.style.cursor = "pointer";
        copyBtn.style.padding = "2px";
        copyBtn.style.display = "flex";
        copyBtn.style.alignItems = "center";
        copyBtn.style.justifyContent = "center";
        copyBtn.style.color = "#6b7280";
        copyBtn.style.transition = "color 0.2s";
        copyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" role="img" aria-label="copy icon" style="color: currentcolor;"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.902 16.902a4 4 0 0 0 .643-.147 5 5 0 0 0 3.21-3.21C21 12.792 21 11.861 21 10s0-2.792-.245-3.545a5 5 0 0 0-3.21-3.21C16.792 3 15.861 3 14 3s-2.792 0-3.545.245a5 5 0 0 0-3.21 3.21 4 4 0 0 0-.147.643m9.804 9.804C17 16.239 17 15.372 17 14c0-1.861 0-2.792-.245-3.545a5 5 0 0 0-3.21-3.21C12.792 7 11.861 7 10 7c-1.373 0-2.24 0-2.902.098m9.804 9.804a4 4 0 0 1-.147.643 5 5 0 0 1-3.21 3.21C12.792 21 11.861 21 10 21s-2.792 0-3.545-.245a5 5 0 0 1-3.21-3.21C3 16.792 3 15.861 3 14s0-2.792.245-3.545a5 5 0 0 1 3.21-3.21c.198-.065.407-.112.643-.147" fill="none"></path></svg>`;
        copyBtn.onmouseenter = () => {
          copyBtn.style.color = "#3b82f6";
        };
        copyBtn.onmouseleave = () => {
          copyBtn.style.color = "#6b7280";
        };
        copyBtn.onclick = () => {
          copyMessageToClipboard(content);
        };

        // Thumbs up button
        const thumbsUpBtn = document.createElement("button");
        thumbsUpBtn.className = "chatbot-feedback-btn chatbot-feedback-like";
        thumbsUpBtn.setAttribute("aria-label", "Like this message");
        thumbsUpBtn.style.background = "none";
        thumbsUpBtn.style.border = "none";
        thumbsUpBtn.style.cursor = "pointer";
        thumbsUpBtn.style.padding = "2px";
        thumbsUpBtn.style.display = "flex";
        thumbsUpBtn.style.alignItems = "center";
        thumbsUpBtn.style.justifyContent = "center";
        thumbsUpBtn.style.color = "#6b7280";
        thumbsUpBtn.style.transition = "color 0.2s";
        thumbsUpBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-thumbs-up"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z"/></svg>`;
        thumbsUpBtn.onmouseenter = () => {
          if (!thumbsUpBtn.classList.contains("active")) {
            thumbsUpBtn.style.color = "#10b981";
          }
        };
        thumbsUpBtn.onmouseleave = () => {
          if (!thumbsUpBtn.classList.contains("active")) {
            thumbsUpBtn.style.color = "#6b7280";
          }
        };
        thumbsUpBtn.onclick = () => {
          submitFeedback(messageId, "like");
          thumbsUpBtn.classList.add("active");
          thumbsUpBtn.style.color = "#10b981";
          thumbsDownBtn.classList.remove("active");
          thumbsDownBtn.style.color = "#6b7280";
        };

        // Thumbs down button
        const thumbsDownBtn = document.createElement("button");
        thumbsDownBtn.className =
          "chatbot-feedback-btn chatbot-feedback-dislike";
        thumbsDownBtn.setAttribute("aria-label", "Dislike this message");
        thumbsDownBtn.style.background = "none";
        thumbsDownBtn.style.border = "none";
        thumbsDownBtn.style.cursor = "pointer";
        thumbsDownBtn.style.padding = "2px";
        thumbsDownBtn.style.display = "flex";
        thumbsDownBtn.style.alignItems = "center";
        thumbsDownBtn.style.justifyContent = "center";
        thumbsDownBtn.style.color = "#6b7280";
        thumbsDownBtn.style.transition = "color 0.2s";
        thumbsDownBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-thumbs-down"><path d="M17 14V2"/><path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z"/></svg>`;
        thumbsDownBtn.onmouseenter = () => {
          if (!thumbsDownBtn.classList.contains("active")) {
            thumbsDownBtn.style.color = "#ef4444";
          }
        };
        thumbsDownBtn.onmouseleave = () => {
          if (!thumbsDownBtn.classList.contains("active")) {
            thumbsDownBtn.style.color = "#6b7280";
          }
        };
        thumbsDownBtn.onclick = () => {
          submitFeedback(messageId, "dislike");
          thumbsDownBtn.classList.add("active");
          thumbsDownBtn.style.color = "#ef4444";
          thumbsUpBtn.classList.remove("active");
          thumbsUpBtn.style.color = "#6b7280";
        };

        // Relative time display
        const timeDiv = document.createElement("div");
        timeDiv.className = "chatbot-message-time";
        // Parse timestamp with proper UTC handling
        let messageDate;
        if (timestamp) {
          if (typeof timestamp === "string") {
            // If timestamp doesn't have timezone info, assume it's UTC and add Z
            let timestampStr = timestamp;
            if (
              !timestampStr.endsWith("Z") &&
              !timestampStr.match(/[+-]\d{2}:\d{2}$/)
            ) {
              timestampStr = timestampStr + "Z";
            }
            messageDate = new Date(timestampStr);
          } else {
            messageDate = new Date(timestamp);
          }
        } else {
          messageDate = new Date();
        }
        // Store the date object on the element for dynamic updates
        timeDiv.dataset.timestamp = messageDate.getTime();
        timeDiv.textContent = getRelativeTime(messageDate);
        timeDiv.style.fontSize = "12px";
        timeDiv.style.color = "#6b7280";

        feedbackDiv.appendChild(copyBtn);
        feedbackDiv.appendChild(thumbsUpBtn);
        feedbackDiv.appendChild(thumbsDownBtn);
        feedbackDiv.appendChild(timeDiv);
        messageWrapper.appendChild(feedbackDiv);
      } else {
        // Add timestamp for non-assistant messages or messages without ID
        const timeDiv = document.createElement("div");
        timeDiv.className = "chatbot-message-time";
        // Parse timestamp with proper UTC handling
        let messageDate;
        if (timestamp) {
          if (typeof timestamp === "string") {
            // If timestamp doesn't have timezone info, assume it's UTC and add Z
            let timestampStr = timestamp;
            if (
              !timestampStr.endsWith("Z") &&
              !timestampStr.match(/[+-]\d{2}:\d{2}$/)
            ) {
              timestampStr = timestampStr + "Z";
            }
            messageDate = new Date(timestampStr);
          } else {
            messageDate = new Date(timestamp);
          }
        } else {
          messageDate = new Date();
        }
        // Store the date object on the element for dynamic updates
        timeDiv.dataset.timestamp = messageDate.getTime();
        timeDiv.textContent = getRelativeTime(messageDate);
        timeDiv.style.fontSize = "12px";
        timeDiv.style.color = "#6b7280";
        timeDiv.style.marginTop = "8px";
        messageWrapper.appendChild(timeDiv);
      }

      messageDiv.appendChild(messageWrapper);
    } else {
      // User message (no avatar)
      const contentDiv = document.createElement("div");
      contentDiv.className = "chatbot-message-content";
      contentDiv.textContent = content;

      // Apply styling if available
      if (window.chatbotStyling) {
        const colors = getCurrentColors(window.chatbotStyling);
        contentDiv.style.backgroundColor = colors.colorUserMessage;
        const radius = `${colors.borderRadiusMessages}px`;
        // Remove bottom-right corner (corner closest to input)
        contentDiv.style.borderTopLeftRadius = radius;
        contentDiv.style.borderTopRightRadius = radius;
        contentDiv.style.borderBottomLeftRadius = radius;
        contentDiv.style.borderBottomRightRadius = "0";
      }

      messageDiv.appendChild(contentDiv);
    }

    messagesContainer.appendChild(messageDiv);

    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Add to messages array with all metadata
    messages.push({
      role,
      content,
      messageId,
      agentName,
      timestamp: timestamp
        ? typeof timestamp === "string"
          ? timestamp
          : timestamp.toISOString()
        : new Date().toISOString(),
    });

    // Update conversation metadata after adding message
    // Note: currentConversationId is set by backend when conversation is created
    if (currentConversationId) {
      const title = getConversationTitle();
      updateConversationMetadata(
        currentConversationId,
        title,
        "active",
        new Date().toISOString()
      );
    }
  }

  // Create a new assistant message bubble for streaming
  function createStreamingAssistantMessage() {
    const messagesContainer = document.getElementById("chatbot-messages");
    if (!messagesContainer) return null;

    // Remove welcome if present
    const welcome = messagesContainer.querySelector(".chatbot-welcome");
    if (welcome) {
      welcome.remove();
    }

    // Hide examples
    const examples = document.getElementById("chatbot-examples");
    if (examples) {
      examples.style.display = "none";
    }
    const examplesSeparator = document.querySelector(
      ".chatbot-examples-separator"
    );
    if (examplesSeparator) {
      examplesSeparator.style.display = "none";
    }

    const messageDiv = document.createElement("div");
    messageDiv.className = "chatbot-message assistant";

    const messageWrapper = document.createElement("div");
    messageWrapper.className = "chatbot-message-wrapper";
    messageWrapper.style.display = "flex";
    messageWrapper.style.flexDirection = "column";
    messageWrapper.style.alignItems = "flex-start";

    const contentDiv = document.createElement("div");
    contentDiv.className = "chatbot-message-content";

    const headerDiv = document.createElement("div");
    headerDiv.className = "chatbot-message-header";

    const avatar = document.createElement("img");
    avatar.className = "chatbot-message-avatar";
    const apiUrl = getApiUrl();
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;
    avatar.src = `${baseUrl}/chat-logo.png`;
    avatar.alt = "Bot";

    const nameDiv = document.createElement("div");
    nameDiv.className = "chatbot-message-name";
    const chatbotName = widgetConfig?.name || "Chatbot";
    nameDiv.textContent = chatbotName;

    headerDiv.appendChild(avatar);
    headerDiv.appendChild(nameDiv);

    const textDiv = document.createElement("div");
    textDiv.className = "chatbot-message-text";
    textDiv.innerHTML = "";

    contentDiv.appendChild(headerDiv);
    contentDiv.appendChild(textDiv);

    // Apply styling if available
    if (window.chatbotStyling) {
      const colors = getCurrentColors(window.chatbotStyling);
      contentDiv.style.backgroundColor = colors.colorBotMessage;
      const radius = `${colors.borderRadiusMessages}px`;
      contentDiv.style.borderTopLeftRadius = radius;
      contentDiv.style.borderTopRightRadius = radius;
      contentDiv.style.borderBottomLeftRadius = "0";
      contentDiv.style.borderBottomRightRadius = radius;
    }

    messageWrapper.appendChild(contentDiv);
    messageDiv.appendChild(messageWrapper);
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    return {
      messageDiv,
      textElement: textDiv,
      text: "",
    };
  }

  // Get relative time string (e.g., "21 hours ago", "2 minutes ago")
  function getRelativeTime(date) {
    // Validate date
    if (!date || isNaN(date.getTime())) {
      return "just now";
    }

    const now = new Date();
    const diffMs = now.getTime() - date.getTime();

    // Handle negative differences (future dates) or very small differences
    if (diffMs < 0) {
      return "just now";
    }

    const diffSecs = Math.floor(diffMs / 1000);
    const diffMins = Math.floor(diffSecs / 60);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    const diffWeeks = Math.floor(diffDays / 7);
    const diffMonths = Math.floor(diffDays / 30);
    const diffYears = Math.floor(diffDays / 365);

    if (diffSecs < 10) {
      return "just now";
    } else if (diffSecs < 60) {
      return `${diffSecs} ${diffSecs === 1 ? "second" : "seconds"} ago`;
    } else if (diffMins < 60) {
      return `${diffMins} ${diffMins === 1 ? "minute" : "minutes"} ago`;
    } else if (diffHours < 24) {
      return `${diffHours} ${diffHours === 1 ? "hour" : "hours"} ago`;
    } else if (diffDays < 7) {
      return `${diffDays} ${diffDays === 1 ? "day" : "days"} ago`;
    } else if (diffWeeks < 4) {
      return `${diffWeeks} ${diffWeeks === 1 ? "week" : "weeks"} ago`;
    } else if (diffMonths < 12) {
      return `${diffMonths} ${diffMonths === 1 ? "month" : "months"} ago`;
    } else {
      return `${diffYears} ${diffYears === 1 ? "year" : "years"} ago`;
    }
  }

  // Update all timestamp displays dynamically
  function updateAllTimestamps() {
    const timeElements = document.querySelectorAll(".chatbot-message-time");
    timeElements.forEach((timeDiv) => {
      const timestamp = timeDiv.dataset.timestamp;
      if (timestamp) {
        const messageDate = new Date(parseInt(timestamp));
        timeDiv.textContent = getRelativeTime(messageDate);
      }
    });
  }

  // Start periodic timestamp updates (every 30 seconds for efficiency)
  let timestampUpdateInterval = null;
  function startTimestampUpdates() {
    if (timestampUpdateInterval) return; // Already running
    timestampUpdateInterval = setInterval(updateAllTimestamps, 30000); // Update every 30 seconds
  }

  function stopTimestampUpdates() {
    if (timestampUpdateInterval) {
      clearInterval(timestampUpdateInterval);
      timestampUpdateInterval = null;
    }
  }

  // Copy message content to clipboard
  async function copyMessageToClipboard(text) {
    try {
      // Strip HTML tags if present (from markdown rendering)
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = text;
      const plainText = tempDiv.textContent || tempDiv.innerText || text;

      await navigator.clipboard.writeText(plainText);
      console.log("[WIDGET] ✅ Message copied to clipboard");
    } catch (error) {
      console.error("[WIDGET] ❌ Error copying to clipboard:", error);
      // Fallback for older browsers
      try {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.opacity = "0";
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
        console.log("[WIDGET] ✅ Message copied to clipboard (fallback)");
      } catch (fallbackError) {
        console.error("[WIDGET] ❌ Fallback copy failed:", fallbackError);
      }
    }
  }

  // Submit feedback for a message
  async function submitFeedback(messageId, feedback) {
    const apiUrl = getApiUrl();
    const baseUrl = apiUrl.endsWith("/") ? apiUrl.slice(0, -1) : apiUrl;

    try {
      const response = await fetch(
        `${baseUrl}/api/chat/messages/${messageId}/feedback`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ feedback }),
        }
      );

      if (response.ok) {
        console.log(
          `[WIDGET] ✅ Feedback submitted: ${feedback} for message ${messageId}`
        );
      } else {
        console.error(
          `[WIDGET] ❌ Failed to submit feedback: ${response.status}`
        );
      }
    } catch (error) {
      console.error("[WIDGET] ❌ Error submitting feedback:", error);
    }
  }

  // Send message
  function sendMessage() {
    console.log("[WIDGET] sendMessage called");
    const input = document.getElementById("chatbot-input");

    if (!input) {
      console.error("[WIDGET] ❌ Input element not found");
      return;
    }

    // Don't send if in history view
    if (isHistoryView) {
      return;
    }

    if (!websocket) {
      console.error("[WIDGET] ❌ WebSocket not initialized");
      return;
    }

    if (websocket.readyState !== WebSocket.OPEN) {
      console.error(
        "[WIDGET] ❌ WebSocket not open. State:",
        websocket.readyState
      );
      return;
    }

    const message = input.value.trim();
    if (!message) {
      console.log("[WIDGET] ⚠️ Empty message, ignoring");
      return;
    }

    console.log("[WIDGET] Sending message:", message);

    // Note: Conversation ID will be set by backend when conversation is created via WebSocket
    // We don't create it here - the backend handles conversation creation

    // Add user message to UI
    addMessage("user", message);

    // Clear input and reset textarea height
    input.value = "";
    input.style.height = "auto";

    // Show typing indicator immediately (optimistic UI)
    const typingIndicator = getTypingIndicator();
    const messagesContainer = document.getElementById("chatbot-messages");
    if (typingIndicator && messagesContainer) {
      messagesContainer.appendChild(typingIndicator);
      typingIndicator.style.display = "flex";
      // Scroll to show typing indicator
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 10);
    }

    // Send via WebSocket
    // If we have a currentConversationId, include it to ensure message goes to correct conversation
    const payload = {
      type: "message",
      message: message,
    };

    // CRITICAL: Only include conversation_uuid if we're continuing an existing conversation
    // If currentConversationId is null, we're starting a NEW conversation
    // The backend will create a new conversation based on the sessionId
    if (currentConversationId) {
      payload.conversation_uuid = currentConversationId;
      console.log(
        "[WIDGET] ✅ Sending message to EXISTING conversation:",
        currentConversationId
      );
    } else {
      // NO conversation_uuid = backend will create a NEW conversation
      console.log(
        "[WIDGET] ✅ Sending message to CREATE NEW conversation (no conversation_uuid)"
      );
      console.log("[WIDGET] ✅ Using sessionId:", sessionId);
    }

    console.log("[WIDGET] Sending payload:", payload);
    websocket.send(JSON.stringify(payload));
    console.log("[WIDGET] ✅ Message sent via WebSocket");
  }

  // Check if popups have been dismissed for this chatbot
  function arePopupsDismissed() {
    if (!widgetConfig) return true;
    const key = `chatbot_popup_dismissed_${widgetConfig.uuid}`;
    return localStorage.getItem(key) === "true";
  }

  // Mark popups as dismissed
  function dismissPopups() {
    if (!widgetConfig) return;
    const key = `chatbot_popup_dismissed_${widgetConfig.uuid}`;
    localStorage.setItem(key, "true");
  }

  // Display popup messages above the button
  function displayPopupMessages() {
    if (!widgetConfig) return;

    const popupContainer = document.getElementById("chatbot-popup-messages");
    if (!popupContainer) return;

    // Clear existing popups
    popupContainer.innerHTML = "";

    // Check if popups have been dismissed - if so, never show them again
    if (arePopupsDismissed()) {
      popupContainer.style.display = "none";
      return;
    }

    // Only show popups when chat is closed
    if (isOpen) {
      popupContainer.style.display = "none";
      return;
    }

    const messages = [];
    if (widgetConfig.popupMessage1) {
      messages.push(widgetConfig.popupMessage1);
    }
    if (widgetConfig.popupMessage2) {
      messages.push(widgetConfig.popupMessage2);
    }

    if (messages.length === 0) {
      popupContainer.style.display = "none";
      return;
    }

    popupContainer.style.display = "flex";

    messages.forEach((message) => {
      const popupDiv = document.createElement("div");
      popupDiv.className = "chatbot-popup-message";
      popupDiv.textContent = message;
      popupContainer.appendChild(popupDiv);
    });
  }

  // Toggle widget
  function toggleWidget() {
    // Mark popups as dismissed on first click
    if (!arePopupsDismissed()) {
      dismissPopups();
    }

    isOpen = !isOpen;
    const window = document.getElementById("chatbot-window");
    const button = document.getElementById("chatbot-button");
    const iconOpen = document.getElementById("chatbot-button-icon-open");
    const iconClose = document.getElementById("chatbot-button-icon-close");

    if (window && button && iconOpen && iconClose) {
      if (isOpen) {
        window.style.display = "flex";
        iconOpen.style.display = "none";
        iconClose.style.display = "block";

        // Hide popup messages when chat opens
        displayPopupMessages();

        // Initialize session if needed
        if (!sessionId) {
          sessionId = generateSessionId();
        }

        // Try to restore last active conversation from backend
        (async () => {
          const fetchedConversations = await fetchConversationsForHistory();
          if (fetchedConversations && fetchedConversations.length > 0) {
            // Update in-memory cache
            conversationHistory = fetchedConversations;

            const lastActiveConversation = fetchedConversations.find(
              (c) => c.status === "active"
            );

            if (lastActiveConversation) {
              // Load the conversation
              await loadConversation(lastActiveConversation.uuid);
              return; // Early return, loadConversation handles UI
            }
          }

          // No active conversation found, start fresh
          currentConversationId = null;
        })();

        // Fetch chatbot config if not loaded
        if (!widgetConfig) {
          loadChatbotConfig(true);
        } else {
          connectWebSocket();
        }

        // Focus input
        setTimeout(() => {
          const input = document.getElementById("chatbot-input");
          if (input) input.focus();
        }, 100);
      } else {
        window.style.display = "none";
        iconOpen.style.display = "block";
        iconClose.style.display = "none";

        // Save conversation metadata before closing (messages are on backend)
        if (currentConversationId && messages.length > 0) {
          const title = getConversationTitle();
          updateConversationMetadata(
            currentConversationId,
            title,
            "active",
            new Date().toISOString()
          );
        }

        // Don't show popup messages when chat closes - they're dismissed after first click
        displayPopupMessages();

        // Close WebSocket
        if (websocket) {
          websocket.close();
          websocket = null;
        }

        // Close menu dropdown if open
        closeMenuDropdown();

        // Switch back to messages view if in history view
        if (isHistoryView) {
          showMessagesView();
        }
      }
    }
  }

  // Check if dark mode is active
  function isDarkMode() {
    return (
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches
    );
  }

  // Get current colors based on dark mode
  function getCurrentColors(styling) {
    const isDark = isDarkMode();

    if (isDark && styling.colorPrimaryDark) {
      return {
        colorPrimary: styling.colorPrimaryDark,
        colorUserMessage:
          styling.colorUserMessageDark || styling.colorUserMessage,
        colorBotMessage: styling.colorBotMessageDark || styling.colorBotMessage,
        colorBackground: styling.colorBackgroundDark || styling.colorBackground,
        borderRadiusChatbot: styling.borderRadiusChatbot,
        borderRadiusMessages: styling.borderRadiusMessages,
        borderRadiusInput: styling.borderRadiusInput,
      };
    }

    // Use light mode colors (default)
    return {
      colorPrimary: styling.colorPrimary,
      colorUserMessage: styling.colorUserMessage,
      colorBotMessage: styling.colorBotMessage,
      colorBackground: styling.colorBackground,
      borderRadiusChatbot: styling.borderRadiusChatbot,
      borderRadiusMessages: styling.borderRadiusMessages,
      borderRadiusInput: styling.borderRadiusInput,
    };
  }

  // Apply styling dynamically
  function applyStyling(styling) {
    // Store styling for future elements first
    window.chatbotStyling = styling;

    // Get current colors based on dark mode
    const colors = getCurrentColors(styling);

    // Apply colors and border radius
    const chatbotButton = document.getElementById("chatbot-button");
    const chatbotHeader = document.querySelector(".chatbot-header");
    const chatbotWindow = document.querySelector(".chatbot-window");
    const chatbotMessages = document.getElementById("chatbot-messages");
    const inputContainer = document.querySelector(".chatbot-input-container");

    if (chatbotButton) {
      chatbotButton.style.backgroundColor = colors.colorPrimary;
    }

    if (chatbotHeader) {
      chatbotHeader.style.backgroundColor = colors.colorPrimary;
    }

    if (chatbotWindow) {
      chatbotWindow.style.backgroundColor = colors.colorBackground;
      chatbotWindow.style.borderRadius = `${colors.borderRadiusChatbot}px`;
    }

    if (chatbotMessages) {
      chatbotMessages.style.backgroundColor = colors.colorBackground;
    }

    if (inputContainer) {
      inputContainer.style.backgroundColor = colors.colorBackground;
    }

    // Apply user message colors
    const userMessages = document.querySelectorAll(
      ".chatbot-message.user .chatbot-message-content"
    );
    userMessages.forEach((msg) => {
      msg.style.backgroundColor = colors.colorUserMessage;
      const radius = `${colors.borderRadiusMessages}px`;
      // Remove bottom-right corner (corner closest to input)
      msg.style.borderTopLeftRadius = radius;
      msg.style.borderTopRightRadius = radius;
      msg.style.borderBottomLeftRadius = radius;
      msg.style.borderBottomRightRadius = "0";
    });

    // Apply bot message colors and border radius
    const botMessages = document.querySelectorAll(
      ".chatbot-message.assistant .chatbot-message-content, .chatbot-message.agent .chatbot-message-content"
    );
    botMessages.forEach((msg) => {
      msg.style.backgroundColor = colors.colorBotMessage;
      const radius = `${colors.borderRadiusMessages}px`;
      // Remove bottom-left corner (corner closest to input)
      msg.style.borderTopLeftRadius = radius;
      msg.style.borderTopRightRadius = radius;
      msg.style.borderBottomLeftRadius = "0";
      msg.style.borderBottomRightRadius = radius;
    });

    // Apply to welcome message
    const welcomeMsg = document.querySelector(".chatbot-welcome");
    if (welcomeMsg) {
      welcomeMsg.style.backgroundColor = colors.colorBotMessage;
      const radius = `${colors.borderRadiusMessages}px`;
      // Remove bottom-left corner (corner closest to input)
      welcomeMsg.style.borderTopLeftRadius = radius;
      welcomeMsg.style.borderTopRightRadius = radius;
      welcomeMsg.style.borderBottomLeftRadius = "0";
      welcomeMsg.style.borderBottomRightRadius = radius;
    }

    // Apply to typing indicator
    const typingIndicator = document.querySelector(
      ".typing-indicator-container"
    );
    if (typingIndicator) {
      typingIndicator.style.backgroundColor = colors.colorBotMessage;
      const radius = `${colors.borderRadiusMessages}px`;
      // Remove bottom-left corner (corner closest to input)
      typingIndicator.style.borderTopLeftRadius = radius;
      typingIndicator.style.borderTopRightRadius = radius;
      typingIndicator.style.borderBottomLeftRadius = "0";
      typingIndicator.style.borderBottomRightRadius = radius;
    }

    // Apply to input field and wrapper
    const inputField = document.getElementById("chatbot-input");
    const inputWrapper = document.querySelector(".chatbot-input-wrapper");
    if (inputField) {
      inputField.style.borderRadius = `${colors.borderRadiusInput}px`;
    }
    if (inputWrapper) {
      inputWrapper.style.borderRadius = `${colors.borderRadiusInput}px`;
    }
  }

  // Setup dark mode listener
  function setupDarkModeListener() {
    if (window.matchMedia) {
      darkModeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
      darkModeMediaQuery.addEventListener("change", () => {
        // Reapply styling when dark mode changes
        if (window.chatbotStyling) {
          applyStyling(window.chatbotStyling);
        }
      });
    }
  }

  // Load chatbot configuration
  async function loadChatbotConfig(connectWs = false) {
    const chatbotUuid = getChatbotUuid();
    if (!chatbotUuid) {
      console.error("Chatbot UUID not found");
      return;
    }

    const apiUrl = getApiUrl();
    try {
      // Fetch chatbot info from public endpoint
      const response = await fetch(
        `${apiUrl}/api/chatbots/${chatbotUuid}/public`
      );
      if (response.ok) {
        const data = await response.json();
        widgetConfig = {
          uuid: data.uuid,
          name: data.name,
          welcomeMessage:
            data.welcome_message || "Hi! What can I help you with?",
          exampleMessages: (() => {
            try {
              return data.example_messages
                ? JSON.parse(data.example_messages)
                : [];
            } catch {
              return [];
            }
          })(),
          windowWidth: data.window_width || 380,
          windowHeight: data.window_height || 600,
          popupMessage1: data.popup_message_1 || null,
          popupMessage2: data.popup_message_2 || null,
          styling: {
            colorPrimary: data.color_primary || "#000000",
            colorUserMessage: data.color_user_message || "#000000",
            colorBotMessage: data.color_bot_message || "#F3F4F6",
            colorBackground: data.color_background || "#FFFFFF",
            borderRadiusChatbot: data.border_radius_chatbot || 16,
            borderRadiusMessages: data.border_radius_messages || 16,
            borderRadiusInput: data.border_radius_input || 24,
            colorPrimaryDark: data.color_primary_dark || null,
            colorUserMessageDark: data.color_user_message_dark || null,
            colorBotMessageDark: data.color_bot_message_dark || null,
            colorBackgroundDark: data.color_background_dark || null,
          },
        };

        // Apply styling
        applyStyling(widgetConfig.styling);

        // Apply window size
        const chatbotWindow = document.getElementById("chatbot-window");
        if (chatbotWindow) {
          chatbotWindow.style.width = widgetConfig.windowWidth + "px";
          chatbotWindow.style.height = widgetConfig.windowHeight + "px";
        }

        // Display popup messages
        displayPopupMessages();

        // Update title in header
        const titleElement = document.querySelector(".chatbot-title");
        if (titleElement) {
          titleElement.textContent = data.name;
        }

        // Update welcome message
        const welcomeTextElement = document.querySelector(
          ".chatbot-welcome-text"
        );
        if (welcomeTextElement && widgetConfig.welcomeMessage) {
          welcomeTextElement.textContent = widgetConfig.welcomeMessage;
        }

        // Display example messages
        try {
          displayExampleMessages();
        } catch (e) {
          console.error("Error displaying example messages:", e);
        }

        // Update typing indicator name
        const typingNameElement = document.querySelector(
          "#chatbot-typing .chatbot-message-name"
        );
        if (typingNameElement) {
          typingNameElement.textContent = data.name;
        }
      } else {
        // Fallback if public endpoint fails
        widgetConfig = {
          uuid: chatbotUuid,
          name: "Chatbot",
          welcomeMessage: "Hi! What can I help you with?",
          exampleMessages: [],
          styling: {
            colorPrimary: "#000000",
            colorUserMessage: "#000000",
            colorBotMessage: "#F3F4F6",
            colorBackground: "#FFFFFF",
            borderRadiusChatbot: 16,
            borderRadiusMessages: 16,
            borderRadiusInput: 24,
          },
        };
        applyStyling(widgetConfig.styling);
      }

      // Only connect WebSocket if requested
      if (connectWs) {
        connectWebSocket();
      }
    } catch (error) {
      console.error("Failed to load chatbot config:", error);
      // Fallback
      widgetConfig = {
        uuid: chatbotUuid,
        name: "Chatbot",
        welcomeMessage: "Hi! What can I help you with?",
        exampleMessages: [],
        styling: {
          colorPrimary: "#000000",
          colorUserMessage: "#000000",
          colorBotMessage: "#F3F4F6",
          colorBackground: "#FFFFFF",
          borderRadiusChatbot: 16,
          borderRadiusMessages: 16,
          borderRadiusInput: 24,
        },
      };
      applyStyling(widgetConfig.styling);

      // Only connect WebSocket if requested
      if (connectWs) {
        connectWebSocket();
      }
    }
  }

  // Initialize widget
  function init() {
    // Inject styles
    injectStyles();

    // Setup dark mode listener
    setupDarkModeListener();

    // Create and append widget
    const widget = createWidgetHTML();
    document.body.appendChild(widget);

    // Load chatbot config and apply styling immediately
    loadChatbotConfig();

    // Start dynamic timestamp updates
    startTimestampUpdates();

    // Attach event listeners
    const button = document.getElementById("chatbot-button");
    const menuButton = document.getElementById("chatbot-menu-button");
    const menuHistory = document.getElementById("chatbot-menu-history");
    const menuNewChat = document.getElementById("chatbot-menu-new-chat");
    const menuEndChat = document.getElementById("chatbot-menu-end-chat");
    const sendButton = document.getElementById("chatbot-send");
    const input = document.getElementById("chatbot-input");

    if (button) {
      button.addEventListener("click", toggleWidget);
    }

    if (menuButton) {
      menuButton.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleMenuDropdown();
      });
    }

    if (menuHistory) {
      menuHistory.addEventListener("click", (e) => {
        e.stopPropagation();
        console.log("[WIDGET] History menu item clicked");
        closeMenuDropdown();
        showHistoryView();
      });
    } else {
      console.warn("[WIDGET] ⚠️ History menu button not found");
    }

    if (menuNewChat) {
      menuNewChat.addEventListener("click", () => {
        closeMenuDropdown();
        startNewConversation();
      });
    }

    if (menuEndChat) {
      menuEndChat.addEventListener("click", () => {
        closeMenuDropdown();
        endCurrentConversation();
      });
    }

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
      const dropdown = document.getElementById("chatbot-menu-dropdown");
      const menuBtn = document.getElementById("chatbot-menu-button");
      if (
        dropdown &&
        menuBtn &&
        !dropdown.contains(e.target) &&
        !menuBtn.contains(e.target)
      ) {
        closeMenuDropdown();
      }
    });

    if (sendButton) {
      sendButton.addEventListener("click", sendMessage);
    }

    if (input) {
      // Auto-resize textarea (max 6 lines, then show scrollbar)
      input.addEventListener("input", () => {
        input.style.height = "auto";
        // Calculate max height for 6 lines: (line-height * font-size * 6) + padding
        // 1.5 * 14px * 6 = 126px + 24px padding = 150px
        const maxHeight = 150;
        input.style.height = Math.min(input.scrollHeight, maxHeight) + "px";
      });

      // Handle Enter key: Shift+Enter for new line, Enter to send
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
